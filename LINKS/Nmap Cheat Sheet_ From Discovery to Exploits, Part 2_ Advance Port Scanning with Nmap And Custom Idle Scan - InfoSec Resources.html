
<!-- saved from url=(0133)http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/#article -->
<html class="js svg no-lowbandwidth video adownload supports no-touchevents cssvhunit cssvmaxunit cssvminunit cssvwunit requestanimationframe raf cssanimations backgroundsize csstransforms csstransforms3d preserve3d csstransitions desktop landscape" lang="en-US" prefix="og: http://ogp.me/ns#" slick-uniqueid="3" data-scrolled="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/pd.js"></script><script async="" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/saved_resource"></script><script src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/cb=gapi.loaded_1" async=""></script><script src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/cb=gapi.loaded_0" async=""></script><script id="facebook-jssdk" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/"></script><script id="twitter-wjs" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/widgets.js"></script><script async="" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/analytics.js"></script><script src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/wp-emoji-release.min.js" type="text/javascript"></script><script src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/secureAnonymousFramework"></script><script type="text/javascript" async="" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/embed.js"></script><script async="" type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/count.js"></script><script type="text/javascript" charset="utf-8" async="" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/button.acba75bebf25a5605514ffbb0e01d0eb.js"></script><style type="text/css">* html #li_ui_li_gen_1457931206092_0 a#li_ui_li_gen_1457931206092_0-link{height:1% !important;}#li_ui_li_gen_1457931206092_0{position:relative !important;overflow:visible !important;display:block !important;}#li_ui_li_gen_1457931206092_0 span{-webkit-box-sizing:content-box !important;-moz-box-sizing:content-box !important;box-sizing:content-box !important;}#li_ui_li_gen_1457931206092_0 a#li_ui_li_gen_1457931206092_0-link{border:0 !important;height:20px !important;text-decoration:none !important;padding:0 !important;margin:0 !important;display:inline-block !important;}#li_ui_li_gen_1457931206092_0 a#li_ui_li_gen_1457931206092_0-link:link, #li_ui_li_gen_1457931206092_0 a#li_ui_li_gen_1457931206092_0-link:visited, #li_ui_li_gen_1457931206092_0 a#li_ui_li_gen_1457931206092_0-link:hover, #li_ui_li_gen_1457931206092_0 a#li_ui_li_gen_1457931206092_0-link:active{border:0 !important;text-decoration:none !important;}#li_ui_li_gen_1457931206092_0 a#li_ui_li_gen_1457931206092_0-link:after{content:"." !important;display:block !important;clear:both !important;visibility:hidden !important;line-height:0 !important;height:0 !important;}#li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-logo{background-image:url(https://static.licdn.com/scds/common/u/images/apps/connect/sprites/sprite_connect_v14.png) !important;background-position:0px -593px !important;background-repeat:no-repeat !important;background-color:#0077b5 !important;background-size:initial !important;cursor:pointer !important;border:0 !important;border-right:1px solid #066094 !important;text-indent:-9999em !important;overflow:hidden !important;padding:0 !important;margin:0 !important;position:absolute !important;left:0px !important;top:0px !important;display:block !important;width:20px !important;height:20px !important;float:right !important;border-radius:2px !important;-webkit-border-radius:2px !important;border-top-right-radius:2px !important;border-bottom-right-radius:2px !important;-webkit-border-top-right-radius:2px !important;-webkit-border-bottom-right-radius:2px !important;}#li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-title{color:#fff !important;cursor:pointer !important;display:block !important;white-space:nowrap !important;float:left !important;margin-left:1px !important;vertical-align:top !important;overflow:hidden !important;text-align:center !important;height:18px !important;padding:0 4px 0 23px !important;border:1px solid #000 !important;border-top-color:#0077b5 !important;border-right-color:#0077b5 !important;border-bottom-color:#0077b5 !important;border-left-color:#0077b5 !important;text-shadow:0 -1px #005887 !important;line-height:20px !important;border-radius:2px !important;-webkit-border-radius:2px !important;border-top-right-radius:2px !important;border-bottom-right-radius:2px !important;-webkit-border-top-right-radius:2px !important;-webkit-border-bottom-right-radius:2px !important;background-color:#0077b5 !important;background-image:-webkit-gradient(linear, left top, left bottom, color-stop(0%,#0077b5), color-stop(100%,#0077b5)) !important; background-image: -webkit-linear-gradient(top, #0077b5 0%, #0077b5 100%) !important;}#li_ui_li_gen_1457931206092_0.hovered #li_ui_li_gen_1457931206092_0-title{border:1px solid #000 !important;border-top-color:#0369a0 !important;border-right-color:#0369a0 !important;border-bottom-color:#0369a0 !important;border-left-color:#0369a0 !important;background-color:#0369a0 !important;background-image:-webkit-gradient(linear, left top, left bottom, color-stop(0%,#0369a0), color-stop(100%,#0369a0)) !important; background-image: -webkit-linear-gradient(top, #0369a0 0%, #0369a0 100%) !important;}#li_ui_li_gen_1457931206092_0.clicked #li_ui_li_gen_1457931206092_0-title, #li_ui_li_gen_1457931206092_0.down #li_ui_li_gen_1457931206092_0-title{color:#fff !important;border:1px solid #000 !important;border-top-color:#066094 !important;border-right-color:#066094 !important;border-bottom-color:#066094 !important;border-left-color:#066094 !important;background-color:#066094 !important;background-image:-webkit-gradient(linear, left top, left bottom, color-stop(0%,#066094), color-stop(100%,#066094)) !important; background-image: -webkit-linear-gradient(top, #066094 0%, #066094 100%) !important;}.IN-shadowed #li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-title{}.IN-shadowed #li_ui_li_gen_1457931206092_0.hovered #li_ui_li_gen_1457931206092_0-title{}.IN-shadowed #li_ui_li_gen_1457931206092_0.clicked #li_ui_li_gen_1457931206092_0-title, .IN-shadowed #li_ui_li_gen_1457931206092_0.down #li_ui_li_gen_1457931206092_0-title{}#li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-title-text, #li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-title-text *{color:#fff !important;font-size:11px !important;font-family:Arial, sans-serif !important;font-weight:bold !important;font-style:normal !important;-webkit-font-smoothing:antialiased !important;display:inline-block !important;background:transparent none !important;vertical-align:top !important;height:18px !important;line-height:20px !important;float:none !important;}#li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-title-text strong{font-weight:bold !important;}#li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-title-text em{font-style:italic !important;}#li_ui_li_gen_1457931206092_0.hovered #li_ui_li_gen_1457931206092_0-title-text, #li_ui_li_gen_1457931206092_0.hovered #li_ui_li_gen_1457931206092_0-title-text *{color:#fff !important;}#li_ui_li_gen_1457931206092_0.clicked #li_ui_li_gen_1457931206092_0-title-text, #li_ui_li_gen_1457931206092_0.down #li_ui_li_gen_1457931206092_0-title-text, #li_ui_li_gen_1457931206092_0.clicked #li_ui_li_gen_1457931206092_0-title-text *, #li_ui_li_gen_1457931206092_0.down #li_ui_li_gen_1457931206092_0-title-text *{color:#fff !important;}#li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-title #li_ui_li_gen_1457931206092_0-mark{display:inline-block !important;width:0px !important;overflow:hidden !important;}.success #li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-title{color:#fff !important;border-top-color:#0077b5 !important;border-right-color:#0077b5 !important;border-bottom-color:#0077b5 !important;border-left-color:#0077b5 !important;background-color:#0077b5 !important;background-image:-webkit-gradient(linear, left top, left bottom, color-stop(0%,#0077b5), color-stop(100%,#0077b5)) !important; background-image: -webkit-linear-gradient(top, #0077b5 0%, #0077b5 100%) !important;}.success #li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-title-text, .success #li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-title-text *{color:#fff !important;}.IN-shadowed .success #li_ui_li_gen_1457931206092_0 #li_ui_li_gen_1457931206092_0-title{}.success #li_ui_li_gen_1457931206092_0.hovered #li_ui_li_gen_1457931206092_0-title{color:#fff !important;border-top-color:#0369a0 !important;border-right-color:#0369a0 !important;border-bottom-color:#0369a0 !important;border-left-color:#0369a0 !important;background-color:#0369a0 !important;background-image:-webkit-gradient(linear, left top, left bottom, color-stop(0%,#0369a0), color-stop(100%,#0369a0)) !important; background-image: -webkit-linear-gradient(top, #0369a0 0%, #0369a0 100%) !important;}.success #li_ui_li_gen_1457931206092_0.hovered #li_ui_li_gen_1457931206092_0-title-text, .success #li_ui_li_gen_1457931206092_0.hovered #li_ui_li_gen_1457931206092_0-title-text *{color:#fff !important;}.success #li_ui_li_gen_1457931206092_0.clicked #li_ui_li_gen_1457931206092_0-title, .success #li_ui_li_gen_1457931206092_0.down #li_ui_li_gen_1457931206092_0-title{color:#fff !important;border-top-color:#066094 !important;border-right-color:#066094 !important;border-bottom-color:#066094 !important;border-left-color:#066094 !important;background-color:#066094 !important;background-image:-webkit-gradient(linear, left top, left bottom, color-stop(0%,#066094), color-stop(100%,#066094)) !important; background-image: -webkit-linear-gradient(top, #066094 0%, #066094 100%) !important;}.success #li_ui_li_gen_1457931206092_0.clicked #li_ui_li_gen_1457931206092_0-title-text, .success #li_ui_li_gen_1457931206092_0.down #li_ui_li_gen_1457931206092_0-title-text, .success #li_ui_li_gen_1457931206092_0.clicked #li_ui_li_gen_1457931206092_0-title-text *, .success #li_ui_li_gen_1457931206092_0.down #li_ui_li_gen_1457931206092_0-title-text *{color:#fff !important;}.IN-shadowed .success #li_ui_li_gen_1457931206092_0.clicked #li_ui_li_gen_1457931206092_0-title, .IN-shadowed .success #li_ui_li_gen_1457931206092_0.down #li_ui_li_gen_1457931206092_0-title{}#li_ui_li_gen_1457931206137_1-container.IN-top {display:inline-block !important;overflow:visible !important;position:relative !important;height:42px !important;line-height:1px !important;cursor:pointer !important;}#li_ui_li_gen_1457931206137_1.IN-top {display:inline-block !important;height:42px !important;width:60px !important;text-align:center !important;background-image:url(https://static.licdn.com/scds/common/u/images/apps/connect/sprites/sprite_connect_v14.png) !important;background-color:transparent !important;background-repeat:no-repeat !important;background-position:-207px -470px !important;}#li_ui_li_gen_1457931206137_1-content.IN-top {display:inline !important;font-size:16px !important;color:#4e4e4e !important;font-weight:bold !important;font-family:Arial, sans-serif !important;line-height:38px !important;}#li_ui_li_gen_1457931206137_1-container.IN-empty #li_ui_li_gen_1457931206137_1-inner.IN-top {background-image:url(https://static.licdn.com/scds/common/u/images/apps/connect/sprites/sprite_connect_v14.png) !important;background-color:transparent !important;background-repeat:no-repeat !important;background-position:0px -560px !important;background-size:initial !important;overflow:hidden !important;margin:4px auto 0 auto !important;width:28px !important;height:28px !important;display:block !important;}#li_ui_li_gen_1457931206137_1-container.IN-empty #li_ui_li_gen_1457931206137_1-content.IN-top {text-indent:-999px !important;display:inline-block !important;}#li_ui_li_gen_1457931206137_1-container.IN-hidden #li_ui_li_gen_1457931206137_1 {display:none !important;}</style><link type="text/css" rel="stylesheet" id="ig_css_0" media="all" href="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/frontend.css"><link type="text/css" rel="stylesheet" id="ig_css_1" media="all" href="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/default.css"><link type="text/css" rel="stylesheet" id="ig_css_2" media="all" href="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/hello.css"><script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/analytics"></script><script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/analytics(1)"></script></head><body class="single single-post postid-26390 single-format-standard with-series ig_laptop" data-gets-modal=""><div id="ig_body_pushdown" style="display: block; height: 49px;"></div><div class="ig_inline_container ig_loop_start ig_before"></div>

  
  
    <meta charset="UTF-8">

<meta name="description" content="IT Security Training &amp; Resources by InfoSec Institute">

<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="stylesheet" href="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/style.css">
<link rel="pingback" href="http://resources.infosecinstitute.com/xmlrpc.php">
<script>var ajaxUrl = 'http://resources.infosecinstitute.com/wp-admin/admin-ajax.php';</script>

<!-- This site is optimized with the Yoast SEO plugin v2.3.2 - https://yoast.com/wordpress/plugins/seo/ -->
<title>Nmap Cheat Sheet: From Discovery to Exploits, Part 2: Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources</title>
<meta name="description" content="This is our second installment of Nmap cheat sheet. Basically, we will discuss some advanced techniques for Nmap scanning and we will conduct a Man In The">
<link rel="canonical" href="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/">
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Nmap Cheat Sheet: From Discovery to Exploits, Part 2: Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources">
<meta property="og:description" content="This is our second installment of Nmap cheat sheet. Basically, we will discuss some advanced techniques for Nmap scanning and we will conduct a Man In The">
<meta property="og:url" content="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/">
<meta property="og:site_name" content="InfoSec Resources">
<meta property="article:tag" content="feature">
<meta property="article:tag" content="hacking">
<meta property="article:section" content="Hacking">
<meta property="article:published_time" content="2014-05-19T08:37:17+00:00">
<meta property="article:modified_time" content="2015-04-18T20:45:52+00:00">
<meta property="og:updated_time" content="2015-04-18T20:45:52+00:00">
<meta property="og:image" content="http://resources.infosecinstitute.com/wp-content/uploads/Nmap-Intro-03262014.jpg">
<!-- / Yoast SEO plugin. -->

<link rel="alternate" type="application/rss+xml" title="InfoSec Resources » Nmap Cheat Sheet: From Discovery to Exploits, Part 2: Advance Port Scanning with Nmap And Custom Idle Scan Comments Feed" href="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/feed/">
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"http:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/resources.infosecinstitute.com\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.3.3"}};
			!function(a,b,c){function d(a){var c=b.createElement("canvas"),d=c.getContext&&c.getContext("2d");return d&&d.fillText?(d.textBaseline="top",d.font="600 32px Arial","flag"===a?(d.fillText(String.fromCharCode(55356,56812,55356,56807),0,0),c.toDataURL().length>3e3):(d.fillText(String.fromCharCode(55357,56835),0,0),0!==d.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
<link rel="stylesheet" id="cptch_stylesheet-css" href="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/style(1).css" type="text/css" media="all">
<link rel="stylesheet" id="wpjb-glyphs-css" href="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/wpjb-glyphs.css" type="text/css" media="all">
<link rel="stylesheet" id="wpjb-css-css" href="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/frontend(1).css" type="text/css" media="all">
<link rel="stylesheet" id="enlighter-local-css" href="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/EnlighterJS.min.css" type="text/css" media="all">
<!-- This site uses the Google Analytics by Yoast plugin v5.4.4 - Universal enabled - https://yoast.com/wordpress/plugins/google-analytics/ -->
<script type="text/javascript">
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','__gaTracker');

	__gaTracker('create', 'UA-146509-8', 'auto');
	__gaTracker('set', 'forceSSL', true);
	__gaTracker('require', 'displayfeatures');
	__gaTracker('send','pageview');

</script>
<!-- / Google Analytics by Yoast -->
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/modernizr.min.js"></script>
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/device.min.js"></script>
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/mootools-yui-compressed.js"></script>
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/EnlighterJS.min.js"></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://resources.infosecinstitute.com/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://resources.infosecinstitute.com/wp-includes/wlwmanifest.xml"> 
<link rel="shortlink" href="http://resources.infosecinstitute.com/?p=26390">
<script type="text/javascript">/* <![CDATA[ */window.addEvent('domready', function(){if (typeof EnlighterJS == "undefined"){return;};EnlighterJS.Util.Init('pre.EnlighterJSRAW', 'code.EnlighterJSRAW', {"language":"standard","theme":"git","indent":-1,"hover":"hoverEnabled","showLinenumbers":true,"rawButton":true,"infoButton":true,"windowButton":true,"rawcodeDoubleclick":false,"grouping":true,"cryptex":{"enabled":true,"email":"mail@example.tld"}});});/* ]]> */</script>
<style type="text/css" id="syntaxhighlighteranchor"></style>
  

  
    
    <div id="fb-root"></div>
    
          <header class="masthead" style="top: 49px;">
  
  <div>
    <div class="col-3-3">
      
      <nav class="top-left">
        <ul>
                      <li>
  <a href="http://infosecinstitute.com/">InfoSec Institute</a>
      <ul>
              <li>
          <a href="http://www.infosecinstitute.com/courses/security.html">IT Security Boot Camps</a>
        </li>
              <li>
          <a href="http://www.infosecinstitute.com/infosec_institute/contact_us.html">Contact InfoSec</a>
        </li>
              <li>
          <a href="http://www.infosecinstitute.com/enterprise-wide-training2.html">Enterprise &amp; Government</a>
        </li>
          </ul>
  </li>                      <li>
  <a href="http://www.intenseschool.com/">Intense School</a>
  </li>                      <li>
  <a href="http://certs.infosecinstitute.com/">Certification Tracker</a>
  </li>                  </ul>
      </nav>
      
      <nav class="top-right">
        <ul>
                  </ul>
      </nav>
      
    </div>
  </div>
  
  <div>
    <div class="col-3-3">
      
              
        <div class="logo">
          <a href="http://resources.infosecinstitute.com/">
            <img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/logo.svg" alt="InfoSec Resources" title="InfoSec Resources" width="126">
          </a>
        </div>
          
            
      <a class="menu-button mobile" href="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/#site-navigation" data-attr="main:toggle">Menu</a>

      <nav class="main" id="site-navigation">
        
        <a class="mobile" href="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/#" data-attr="main:remove" aria-hidden="true">Close Menu</a>
        <a class="mobile" href="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/#" data-attr="topics:remove" aria-hidden="true">Back</a>
        <a class="mobile" href="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/#" data-attr="content-archives:remove" aria-hidden="true">Back</a>
      
        <ul>
          <li class="mobile menu-item menu-item-type-custom menu-item-object-custom menu-item-4748"><a href="http://infosec.wpengine.com/">Return Home</a></li><li class="has-dropdown  menu-item menu-item-type-custom menu-item-object-custom menu-item-4750 menu-item-has-children"><a href="" data-attr="topics:set">Topics</a><ul data-menu-container="topics"><li><a href="http://resources.infosecinstitute.com/category/hacking-2/" title="Hacking">
                          Hacking
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/certifications-training/" title="IT Certifications">
                          IT Certifications
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/forensics-2/" title="Forensics">
                          Forensics
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/application-security-2/" title="Secure Coding">
                          Secure Coding
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/pen-testing-1/" title="Penetration Testing">
                          Penetration Testing
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/general-security-2/" title="General Security">
                          General Security
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/cloud-computing/" title="Cloud Computing">
                          Cloud Computing
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/interviews/" title="Interviews">
                          Interviews
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/virtualization-security/" title="Virtualization Security">
                          Virtualization Security
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/wireless-security/" title="Wireless Security">
                          Wireless Security
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/scada-2/" title="SCADA / ICS Security">
                          SCADA / ICS Security
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/reverse-engineering-2/" title="Reverse Engineering">
                          Reverse Engineering
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/data-recovery/" title="Data Recovery">
                          Data Recovery
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/exploit-development/" title="Exploit Development">
                          Exploit Development
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/compliance-auditing/" title="Management, Compliance, &amp; Auditing">
                          Management, Compliance, &amp; Auditing
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/incident-response-resources/" title="Incident Response">
                          Incident Response
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/certifications-training/" title="IT Certifications">
                          IT Certifications
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/certifications-training/securityplus/" title="Security+">
                          Security+
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/security-awareness/" title="Security Awareness">
                          Security Awareness
                        </a></li><li><a href="http://resources.infosecinstitute.com/category/phishing/" title="Phishing">
                          Phishing
                        </a></li></ul></li><li class=" menu-item menu-item-type-post_type menu-item-object-page menu-item-4758"><a href="http://resources.infosecinstitute.com/contributors/">Contributors</a></li><li class="has-dropdown desktop menu-item menu-item-type-custom menu-item-object-custom menu-item-30046 menu-item-has-children"><a href="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/#" data-attr="content-archives:set">Content Archives</a><ul data-menu-container="content-archives"><li><a href="http://resources.infosecinstitute.com/2015/" title="2015">
                          2015
                        </a></li><li><a href="http://resources.infosecinstitute.com/2014/" title="2014">
                          2014
                        </a></li><li><a href="http://resources.infosecinstitute.com/2013/" title="2013">
                          2013
                        </a></li><li><a href="http://resources.infosecinstitute.com/2012" title="2012">
                          2012
                        </a></li><li><a href="http://resources.infosecinstitute.com/2011" title="2011">
                          2011
                        </a></li><li><a href="http://resources.infosecinstitute.com/2010" title="2010">
                          2010
                        </a></li></ul></li><li class="mobile menu-item menu-item-type-custom menu-item-object-custom menu-item-30121"><a href="http://resources.infosecinstitute.com/2015">Content Archives</a></li><li class=" menu-item menu-item-type-post_type menu-item-object-page menu-item-32428"><a href="http://resources.infosecinstitute.com/careers/">Job Board</a></li><li class=" menu-item menu-item-type-post_type menu-item-object-page menu-item-32427"><a href="http://resources.infosecinstitute.com/job-titles/">Careers</a></li><li class=" menu-item menu-item-type-custom menu-item-object-custom menu-item-32598"><a href="https://securityiq.infosecinstitute.com/">SecurityIQ Phishing Simulator</a></li>          
        </ul>
      </nav>
      
      <nav class="search">
        <form class="search-form" action="http://www2.infosecinstitute.com/s/12882/ntpoCCBNQ1ttbNTP3ylPLZZeUqLrVgCT" method="get">
  <fieldset>
    <input type="text" name="s" class="icon search" id="search" value="">
    <input type="submit" class="icon search" title="Search">
  </fieldset>
</form>
      </nav>
      
    </div>
  </div>
  
</header>          
    <main>
      
      <section class="hero full">
          
  <div class="col-3-3 wrapper hook" style="background-image: url(&#39;http://2we26u4fam7n16rz3a44uhbe1bq2.wpengine.netdna-cdn.com/wp-content/uploads//Nmap-Intro-03262014-980x0-c-default.jpg&#39;);">
  
    <header>
      <h2>Nmap Cheat Sheet - Part 2</h2>
      <h1>Nmap Cheat Sheet: From Discovery to Exploits, Part 2: Advance Port Scanning with Nmap And Custom Idle Scan</h1>
          </header>
    
    <nav class="jump">
  
  <label>Jump to</label>
  
  <div class="dropdown">
    
    <span data-trigger="">Select post section</span>
    
    <ul>
                        <li>
            <a href="http://resources.infosecinstitute.com/nmap-cheat-sheet/#article">Part 1 - Nmap Cheat Sheet: From Discovery to Exploits – Part 1: Introduction to Nmap</a>
          </li>
                                <li class="current">Part 2 - Nmap Cheat Sheet: From Discovery to Exploits, Part 2: Advance Port Scanning with Nmap And Custom Idle Scan</li>
                                <li>
            <a href="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-3-gathering-additional-information-host-network-2/#article">Part 3 - Nmap Cheat Sheet: From Discovery to Exploits, Part 3: Gathering Additional Information about Host and Network</a>
          </li>
                                <li>
            <a href="http://resources.infosecinstitute.com/nmap-cheat-sheet-part-4/#article">Part 4 - Nmap Cheat Sheet: Part 4</a>
          </li>
                                <li>
            <a href="http://resources.infosecinstitute.com/nmap-cheat-sheet-5-the-final-view-of-a-ninja-pentester/#article">Part 5 - Nmap Cheat Sheet 5: The Final View of a Ninja Pentester</a>
          </li>
                  </ul>
    
    <select>
                        <option value="http://resources.infosecinstitute.com/nmap-cheat-sheet/#article">Part 1 - Nmap Cheat Sheet: From Discovery to Exploits – Part 1: Introduction to Nmap</option>
                                <option selected="">Part 2 - Nmap Cheat Sheet: From Discovery to Exploits, Part 2: Advance Port Scanning with Nmap And Custom Idle Scan</option>
                                <option value="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-3-gathering-additional-information-host-network-2/#article">Part 3 - Nmap Cheat Sheet: From Discovery to Exploits, Part 3: Gathering Additional Information about Host and Network</option>
                                <option value="http://resources.infosecinstitute.com/nmap-cheat-sheet-part-4/#article">Part 4 - Nmap Cheat Sheet: Part 4</option>
                                <option value="http://resources.infosecinstitute.com/nmap-cheat-sheet-5-the-final-view-of-a-ninja-pentester/#article">Part 5 - Nmap Cheat Sheet 5: The Final View of a Ninja Pentester</option>
                  </select>
    
  </div>
  
</nav>    
    <div class="share vertical">

  <ul>
    
    <li class="twitter">
      <iframe id="twitter-widget-1" scrolling="no" frameborder="0" allowtransparency="true" class="twitter-share-button twitter-share-button-rendered twitter-tweet-button" title="Twitter Tweet Button" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/tweet_button.c60d5b0c77548151ea09cd595348dc2d.en.html" style="position: static; visibility: visible; width: 61px; height: 20px;" data-url="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/"></iframe>
    </li>
    
    <li class="google">
      <div id="___plus_0" style="text-indent: 0px; margin: 0px; padding: 0px; border-style: none; float: none; line-height: normal; font-size: 1px; vertical-align: baseline; display: inline-block; width: 60px; height: 60px; background: transparent;"><iframe frameborder="0" hspace="0" marginheight="0" marginwidth="0" scrolling="no" style="position: static; top: 0px; width: 60px; margin: 0px; border-style: none; left: 0px; visibility: visible; height: 60px;" tabindex="0" vspace="0" width="100%" id="I0_1457931191140" name="I0_1457931191140" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/sharebutton.html" data-gapiattached="true" title="+Share"></iframe></div>
    </li>
    
    <li class="linkedin">
      <span class="IN-widget" style="line-height: 1; vertical-align: baseline; display: inline-block; text-align: center;"><span style="padding: 0px !important; margin: 0px !important; text-indent: 0px !important; display: inline-block !important; vertical-align: baseline !important; font-size: 1px !important;"><span id="li_ui_li_gen_1457931206137_1-container" class="IN-top"><span id="li_ui_li_gen_1457931206137_1" class="IN-top"><span id="li_ui_li_gen_1457931206137_1-inner" class="IN-top"><span id="li_ui_li_gen_1457931206137_1-content" class="IN-top">159</span></span></span></span></span><br><span style="padding: 0px !important; margin: 0px !important; text-indent: 0px !important; display: inline-block !important; vertical-align: baseline !important; font-size: 1px !important;"><span id="li_ui_li_gen_1457931206092_0"><a id="li_ui_li_gen_1457931206092_0-link" href="javascript:void(0);"><span id="li_ui_li_gen_1457931206092_0-logo">in</span><span id="li_ui_li_gen_1457931206092_0-title"><span id="li_ui_li_gen_1457931206092_0-mark"></span><span id="li_ui_li_gen_1457931206092_0-title-text">Share</span></span></a></span></span></span><script type="IN/Share+init" data-counter="top"></script>
    </li>
    
    <li class="reddit">
      <script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/button2.js"></script><iframe src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/button2.html" height="69" width="51" scrolling="no" frameborder="0"></iframe>
    </li>
    
    <li class="facebook">
      <div class="fb-like" data-width="90" data-layout="box_count" data-action="like" data-show-faces="false" data-share="false"></div>
    </li>
    
  </ul>

</div>    
  </div>
  
      </section>
      
      <section class="content full">
        <div class="col-3-3 wrapper">
                      
  <div class="main post-col-3-3">
    
    <article class="post-content">
      <div id="article"></div>
      <div class="ig_inline_container ig_the_content ig_before"></div><p>This is our second installment of Nmap cheat sheet. Basically, we will discuss some advanced techniques for Nmap scanning and we will conduct a Man In The Middle Attack (MITM). Let’s start our game now.</p>
<p><span class="pardot-title">Ethical Hacking Training – Resources (InfoSec)</span><iframe class="pardotform" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/dt6gm.html" width="100%" height="568" type="text/html" frameborder="0" allowtransparency="true" style="border: 0" scrolling="no"></iframe></p>
<p><strong>TCP SYN Scan</strong></p>
<p>SYN scan is the default and most popular scan option, for good reasons. It can be performed quickly, scanning thousands of ports per second on a fast network not hampered by restrictive firewalls. It is also relatively unobtrusive and stealthy, since it never completes TCP connections.</p>
<p><strong>Command: nmap –sS target</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh1.png" alt=""></p>
<p><strong>TCP Connect Scan</strong></p>
<p>TCP connect scan is the default TCP scan type when SYN scan is not an option. This is the case when a user does not have raw packet privileges. Instead of writing raw packets as most other scan types do, Nmap asks the underlying operating system to establish a connection with the target machine and port by issuing the connect system call.</p>
<p><strong>Command: nmap –sT target</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh2.png" alt=""></p>
<p><strong>UDP SCANS</strong></p>
<p>While most popular services on the Internet run over the TCP protocol, <a href="http://www.rfc-editor.org/rfc/rfc768.txt" onclick="__gaTracker(&#39;send&#39;, &#39;event&#39;, &#39;outbound-article&#39;, &#39;http://www.rfc-editor.org/rfc/rfc768.txt&#39;, &#39;UDP&#39;);">UDP</a> services are widely deployed. DNS, SNMP, and DHCP (registered ports 53, 161/162, and 67/68) are three of the most common. Because UDP scanning is generally slower and more difficult than TCP, some security auditors ignore these ports. This is a mistake, as exploitable UDP services are quite common and attackers certainly don’t ignore the whole protocol.</p>
<p><strong>Command: nmap –sU target</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh3.png" alt=""></p>
<p>The –data-length option can be used to send a fixed-length random payload to every port or (if you specify a value of 0) to disable payloads. If an ICMP port unreachable error (type 3, code 3) is returned, the port is closed. Other ICMP unreachable errors (type 3, codes 1, 2, 9, 10, or 13) mark the port as filtered. Occasionally, a service will respond with a UDP packet, proving that it is open. If no response is received after retransmissions, the port is classified as open|filtered.</p>
<p><strong>Command: nmap –sU –data-length=value target</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh4.png" alt=""></p>
<p><strong>SCTP INIT Scan</strong></p>
<p>SCTP is a relatively new alternative to the TCP and UDP protocols, combining most characteristics of TCP and UDP, and also adding new features like multi-homing and multi-streaming. It is mostly being used for SS7/SIGTRAN related services but has the potential to be used for other applications as well. SCTP INIT scan is the SCTP equivalent of a TCP SYN scan. It can be performed quickly, scanning thousands of ports per second on a fast network not hampered by restrictive firewalls. Like SYN scan, INIT scan is relatively unobtrusive and stealthy, since it never completes SCTP associations.</p>
<p><strong>Command: nmap –sY target</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh5.png" alt=""></p>
<p><strong>TCP NULL, FIN, and Xmas scans</strong></p>
<ul>
<li>
<div>NULL scan (-sN)</div>
<p>Does not set any bits (TCP flag header is 0).</p></li>
<li>
<div>FIN scan (-sF)</div>
<p>Sets just the TCP FIN bit.</p></li>
<li>
<div>Xmas scan (-sX)</div>
<p>Sets the FIN, PSH, and URG flags, lighting the packet up like a Christmas tree.</p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh6.png" alt=""></p>
<p><strong>TCP ACK Scan</strong></p>
<p>This scan is different than the others discussed so far in that it never determines open (or even open|filtered) ports. It is used to map out firewall rulesets, determining whether they are stateful or not, and which ports are filtered.</p>
<p><strong>Command: nmap –scanflags=value –sAtarget</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh7.png" alt=""></p>
<p>The ACK scan probe packet has only the ACK flag set (unless you use –scanflags). When scanning unfiltered systems, open and closed ports will both return a RST packet. Nmap then labels them as unfiltered, meaning that they are reachable by the ACK packet.</p>
<p><strong>TCP Window Scan</strong></p>
<p>Window scan is exactly the same as ACK scan, except that it exploits an implementation detail of certain systems to differentiate open ports from closed ones, rather than always printing unfiltered when an RST is returned.</p>
<p><strong>Command: nmap –sW target</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh8.png" alt=""></p>
<p><strong>See the valuable and juicy information which is useful for a hacker to attack further:</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh9.png" alt=""></p>
<p><strong>TCP Maimon Scan</strong></p>
<p>The Maimon scan is named after its discoverer, Uriel Maimon. He described the technique in <em>Phrack</em> Magazine issue #49 (November 1996). Nmap, which included this technique, was released two issues later. This technique is exactly the same as NULL, FIN, and Xmas scans, except that the probe is FIN/ACK.</p>
<p><strong>Command: nmap –sM target</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh10.png" alt=""></p>
<p>&nbsp;</p>
<p><strong>Custom TCP Scan Using –scanflag Options</strong></p>
<p>For advance pentesting, a pentester will not use a general TCP scan like ACK, FIN, etc. because these things may be blocked by IDS/IPS. So they will use some different techniques by specifying “-scanflag” options. This also can be used for firewall evading.</p>
<p>&nbsp;</p>
<p>The –scanflags argument can be a numerical flag value such as 9 (PSH and FIN), but using symbolic names is easier. Just mash together any combination of URG, ACK, PSH, RST, SYN, and FIN. For example, –scanflags URGACKPSHRSTSYNFIN sets everything, though it’s not very useful for scanning.</p>
<p><strong>Command: nmap –-scanflags target</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh11.png" alt=""></p>
<p><strong>SCTP COOKIE ECHO Scan</strong></p>
<p>SCTP COOKIE ECHO scan is a more advanced SCTP scan. It takes advantage of the fact that SCTP implementations should silently drop packets containing COOKIE ECHO chunks on open ports, but send an ABORT if the port is closed. The advantage of this scan type is that it is not as obvious a port scan as an INIT scan. Also, there may be non-stateful firewall rulesets blocking INIT chunks, but not COOKIE ECHO chunks. A good IDS will be able to detect SCTP COOKIE ECHO scans too. The downside is that SCTP COOKIE ECHO scans cannot differentiate between open and filtered ports, leaving you with the state open|filtered in both cases.</p>
<p><strong>Command: nmap –-sZ target</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh12.png" alt=""></p>
<p><strong>TCP Idle Scan</strong></p>
<p>This advanced scan method allows for a truly blind TCP port scan of the target (meaning no packets are sent to the target from your real IP address). Instead, a unique side-channel attack exploits predictable IP fragmentation ID sequence generation on the zombie host to glean information about the open ports on the target. IDS systems will display the scan as coming from the zombie machine you specify. This is very useful for conducting MITM (Man In The Middle Attack).</p>
<p><strong>Command: nmap –sI zombie target<br>
<img class="alignnone wp-image-26392 size-full" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/fig1.gif" alt="fig1" width="555" height="94"></strong></p>
<p>Victim thought that Zombie was the Attacker machine, which it was actually not. So here the Attacker tried to fool the Victim.</p></li>
<li><strong>Here Zombie means the middle man that you have trusted. Zombie can be any machine which acts like a middle machine between Attacker and Victim.</strong>However, we are in advanced pentesting, so let’s try to move ahead with details regarding Idle Scan.<img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh19.png" alt=""><strong>History And Details</strong>In 1998, security researcher Antirez (who also wrote the hping2 tool used in parts of this book) posted to the <a href="http://www.kyuzz.org/antirez/papers/dumbscan.html" onclick="__gaTracker(&#39;send&#39;, &#39;event&#39;, &#39;outbound-article&#39;, &#39;http://www.kyuzz.org/antirez/papers/dumbscan.html&#39;, &#39;Bugtraq&#39;);">Bugtraq</a> mailing list an ingenious new port scanning technique. He called it “dumb scan”. Attackers can actually scan a target without sending a single packet to the target from their own IP address! Instead, a clever side-channel attack allows for the scan to be bounced off a dumb “zombie host”. Intrusion detection system (IDS) reports will finger the innocent zombie as the attacker. Besides being extraordinarily stealthy, this scan type permits discovery of IP-based trust relationships between machines.
<p>What Is the Actual Game?</p>
<p>Actually, for an attacker to conduct this attack, he does not need to be an expert in TCP/IP, but it is more advanced than other techniques as discussed so far. The below steps are put together to conduct this attack.</p></li>
<li>
<div>One way to determine whether a TCP port is open is to send a SYN (session establishment) packet to the port. The target machine will respond with a SYN/ACK (session request acknowledgment) packet if the port is open, and RST (reset) if the port is closed. This is the basis of the previously discussed SYN scan.</div>
</li>
<li>
<div>A machine that receives an unsolicited SYN/ACK packet will respond with a RST. An unsolicited RST will be ignored.</div>
</li>
<li>
<div>Every IP packet on the Internet has a fragment identification number (IP ID). Since many operating systems simply increment this number for each packet they send, probing for the IPID can tell an attacker how many packets have been sent since the last probe.</div>
<p>By combining these traits, it is possible to scan a target network while forging your identity so that it looks like an innocent zombie machine did the scanning.</p>
<p><strong>Idle Scan Explained</strong></p>
<p>To conduct this attack, the following steps may be followed for successful exploitation.</p></li>
</ul>
<ol>
<li>
<div>Probe the zombie’s IP ID and record it.</div>
</li>
<li>
<div>Forge a SYN packet from the zombie and send it to the desired port on the target. Depending on the port state, the target’s reaction may or may not cause the zombie’s IP ID to be incremented.</div>
</li>
<li>
<div>Probe the zombie’s IP ID again. The target port state is then determined by comparing this new IP ID with the one recorded in step 1.</div>
<p><strong>How to Determine from IP ID</strong></p>
<p>From the IP ID value, an attacker will try to learn about port status, whether it is open or filtered or closed. Read below for details:</p></li>
</ol>
<ul>
<li>
<div>After the above idle scan process, the zombie’s IP ID should have increased by either one or two. An increase of one indicates that the zombie hasn’t sent out any packets, except for its reply to the attacker’s probe. This lack of sent packets means that the port is not open (the target must have sent the zombie either a RST packet, which was ignored, or nothing at all).</div>
</li>
<li>
<div>An increase of two indicates that the zombie sent out a packet between the two probes. This extra packet usually means that the port is open (the target presumably sent the zombie a SYN/ACK packet in response to the forged SYN, which induced a RST packet from the zombie).</div>
</li>
<li>
<div>Increases larger than two usually signify a bad zombie host. It might not have predictable IP ID numbers, or might be engaged in communication unrelated to the idle scan.</div>
</li>
</ul>
<p>See the below images that relate Attacker, Zombie, and Victim, and how the attack is conducted.</p>
<p><strong>Idle Scan of an Open Port</strong></p>
<p><strong>Step 1: Probe The Zombie’s IP address</strong></p>
<p>SYN/ACK</p>
<p>RST IPID=31337</p>
<p>The Attacker sends SYN/ACK packets to Zombie. But Zombie is not expecting to get these packets. So in response, he discloses IP ID value by responding with an RST packet to the attacker.</p>
<p><strong>Step 2: Forge SYN packet from zombie</strong></p>
<p>SYN request from Zombie which is spoofed</p>
<p>SYN/ACK to Zombie</p>
<p style="text-align: center;">RST packet.IP ID:31338</p>
<p>The Victim sends a SYN/ACK packet in response to the SYN packet that appears to come from Zombie. The Zombie sends back RST by incrementing IP ID value.</p>
<p><strong>Step3: Probe Zombie’s IP ID again</strong></p>
<p><strong> SYN/ACK </strong></p>
<p style="text-align: center;">Zombie</p>
<p>RST,IP ID:31339</p>
<p>The Zombie’s IP ID increased by two, which is learned from step one.</p>
<p>So here we know that the port is open from the IPID value.</p>
<p>Note<strong>:</strong> If the port is closed, then the IPID value will be increased by one. If the Zombie’s IP ID increased by one as in the first step, we can say that it may be closed or filtered. In the case of filtered, the Victim has no response to Zombie for the SYN request of Attacker.</p>
<p>In this situation, an Attacker will learn that there may be IDS/IPS which have rules to block some certain scan attempts by Zombie machines. For that, he will again use decoy options for Nmap to evade that. We will discuss that later.</p>
<p><strong>Step 1: Finding Zombie Host for Idle Scan</strong></p>
<p>The first step in executing an IP ID idle scan is to find an appropriate zombie. It needs to assign IP ID packets incrementally on a global (rather than per-host it communicates with) basis. It should be idle (hence the scan name), as extraneous traffic will bump up its IP ID sequence, confusing the scan logic.</p>
<p>A common approach is to simply execute a Nmap ping scan of some network. We can use Nmap’s random IP selection mode (-iR), but that is likely to result in far away zombies with substantial latency.</p>
<p>Performing a port scan and OS identification (-O) on the zombie candidate network, rather than just a ping scan, helps in selecting a good zombie. As long as verbose mode (-v) is enabled, OS detection will usually determine the IP ID sequence generation method and print a line such as “IP ID Sequence Generation: Incremental”. If the type is given as Incremental or Broken little-endian incremental, the machine is a good zombie candidate.</p>
<p>Another approach to identifying zombie candidates is to run the ipidseq NSE script against a host. This script probes a host to classify its IP ID generation method, then prints the IP ID classification, much like the OS detection does.</p>
<p>Command: (nmap –script ipidseq [–script-args probeport=port] target)</p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh20.png" alt=""></p>
<p>Now we can tell that it is incremental and a good candidate for Zombie.</p>
<p><strong>Using Hping</strong></p>
<p>We can also use hping for discovering a zombie. The hping method for idle scanning provides a lower level example for how idle scanning is performed. In this example, the target host (target1) will be scanned using an idle host (target2). An open and a closed port will be tested to see how each scenario plays out.</p>
<p>First, establish that the idle host is actually idle, send packets using hping2 and observe the ID numbers increase incrementally by one. If the ID numbers increase haphazardly, the host is not actually idle, or has an OS that has no predictable IP ID.</p>
<p>hping3 -S target</p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh21.png" alt=""></p>
<p>Send a spoofed SYN packet to the target host on a port you expect to be open.</p>
<p>hping3 –spoof Zombie -S p 22 target</p>
<p>*Note: Here I do not want to include the screenshot. Though this is a part of research and this document is for only educational purposes, the owner of the website does not want to disclose it. If you have any doubt you can contact me here or email me.</p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh22.png" alt=""></p>
<p>As you can see, there is no response and it shows 100% packet loss. That means we have failed to find the zombie. Again we will check the following step for confirmation.</p>
<p>Check the IPID value for any increment:</p>
<p>hping3 -S target</p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh23.png" alt=""></p>
<p>No response.</p>
<p>It includes that the port is filtered.</p>
<p><strong>Attack using Nmap</strong></p>
<p>See the image below. We are attacking the target machine using a zombie host.</p>
<p><strong>Command: nmap –Pn –p- -sI zombie target</strong></p>
<p>First we will do an Nmap scan for ports:</p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh24.png" alt=""></p>
<p>Based on that, let’s try port 22, which is already running.</p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh25.png" alt=""></p>
<p>Here we are unable to attack to the target, as it is showing the port is already used for some other purpose. By default, Nmap forges probes to the target from the source port 80 of the zombie. You can choose a different port by appending a colon and port number to the zombie name (e.g. -sI zombie:113). The chosen port must not be filtered from the attacker or the target. A SYN scan of the zombie should show the port in the open or closed state.</p>
<p>Here –Pn: prevents Nmap from sending the initial packets to the target machine.</p>
<p>-p-: will scan all 65535 ports.</p>
<p>-sI: used for idle scan and sending spoof packets.</p>
<p>Here what happens, the attacker’s IDS will think that the packet is coming from a zombie machine, not from the target machine. So he will be confused.</p>
<p><strong>Understanding Nmap Internally</strong></p>
<p>As a pentester, we must understand internal workings of Nmap’s idle scan, so that we will craft the same thing in our own implementation. Even we can write our own code based on Python to do the same thing. We must understand the basic flow or algorithm of Nmap’s idle scan. For that, we will use packet trace options in Nmap.</p>
<p><strong>Command: nmap -sI Zombie:113 -Pn -p20-80,110-180 -r –packet-trace -v target</strong></p>
<p><span style="font-family: Courier New;">–</span>Pn is necessary for stealth, otherwise pinged packets would be sent to the target from the attacker’s real address. Version scanning would also expose the true address, -sV is <em>not</em> specified. The -r option (turns off port randomization) is only used to make this example easier.</p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh26.png" alt=""></p>
<p>As I said before, use a suitable zombie port for successful attack.</p>
<p>Process of this attack:</p>
<p>Nmap firsts tests Zombie’s IP ID sequence generation by sending six SYN/ACK packets to it and analyzing the responses. Here R means Reset packet. That means that is not reachable through that port, though that is already used for other services. For more details, follow the Idle Scan by Nmap Manual (<a href="http://nmap.org/book/idlescan.html" onclick="__gaTracker(&#39;send&#39;, &#39;event&#39;, &#39;outbound-article&#39;, &#39;http://nmap.org/book/idlescan.html&#39;, &#39;http://nmap.org/book/idlescan.html&#39;);">http://nmap.org/book/idlescan.html</a>). Here is a vulnerable machine with a suitable zombie for a successful attack.</p>
<p>So the below mentioned C code is for idle scan. Compile the C program and run the code.</p>
<p>This is an extraordinary scan code that can allow for completely blind scanning (eg. no packets sent to the target from your own IP address) and can also be used to penetrate firewalls and scope out router ACLs.</p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/fig21.gif" alt="" width="242" height="155"></p>
<pre class="brush: cpp; title: ; notranslate" title="">#include "idle_scan.h"
#include "timing.h"
#include "osscan2.h"
#include "nmap.h"
#include "NmapOps.h"
#include "services.h"
#include "Target.h"
#include "utils.h"
#include "output.h"

#include "struct_ip.h"

#include

extern NmapOps o;

struct idle_proxy_info {   create a constructer and take all variable into it
  Target host; /* contains name, IP, source IP, timing info, etc. */
  int seqclass; /* IP ID sequence class (IPID_SEQ_* defined in nmap.h) */
  u16 latestid; /* The most recent IP ID we have received from the proxy */
  u16 probe_port; /* The port we use for probing IP ID infoz */
  u16 max_groupsz; /* We won't test groups larger than this ... */
  u16 min_groupsz; /* We won't allow the group size to fall below this
		      level.  Affected by --min-parallelism */
  double current_groupsz; /* Current group size being used ... depends on
                          conditions ... won't be higher than
                          max_groupsz */
  int senddelay; /* Delay between sending pr0be SYN packets to target
                    (in microseconds) */
  int max_senddelay; /* Maximum time we are allowed to wait between
                        sending pr0bes (when we send a bunch in a row.
                        In microseconds. */

  pcap_t *pd; /* A Pcap descriptor which (starting in
                 initialize_idleproxy) listens for TCP packets from
                 the probe_port of the proxy box */
  int rawsd; /* Socket descriptor for sending probe packets to the proxy */
  struct eth_nfo eth; // For when we want to send probes via raw IP instead.
  struct eth_nfo *ethptr; // points to eth if filled out, otherwise NULL
};

/* Sends an IP ID probe to the proxy machine and returns the IP ID.
   This function handles retransmissions, and returns -1 if it fails.
   Proxy timing is adjusted, but proxy-&gt;latestid is NOT ADJUSTED --
   you'll have to do that yourself.   Probes_sent is set to the number
   of probe packets sent during execution */
static int ipid_proxy_probe(struct idle_proxy_info *proxy, int *probes_sent,
		     int *probes_rcvd) {
  struct timeval tv_end;
  int tries = 0;
  int trynum;
  int sent=0, rcvd=0;
  int maxtries = 3; /* The maximum number of tries before we give up */
  struct timeval tv_sent[3], rcvdtime;
  int ipid = -1;
  int to_usec;
  unsigned int bytes;
  int base_port;
  struct ip *ip;
  struct tcp_hdr *tcp;
  static u32 seq_base = 0;
  static u32 ack = 0;
  static int packet_send_count = 0; /* Total # of probes sent by this program -- to ensure that our sequence # always changes */

  if (o.magic_port_set)
    base_port = o.magic_port;
  else base_port = o.magic_port + get_random_u8();

  if (seq_base == 0) seq_base = get_random_u32();
  if (!ack) ack = get_random_u32();

  do {
    gettimeofday(&amp;tv_sent[tries], NULL);

    /* Time to send the pr0be!*/
    send_tcp_raw(proxy-&gt;rawsd, proxy-&gt;ethptr,
    		proxy-&gt;host.v4sourceip(), proxy-&gt;host.v4hostip(),
    		o.ttl, false,
    		o.ipoptions, o.ipoptionslen,
    		base_port + tries, proxy-&gt;probe_port,
		seq_base + (packet_send_count++ * 500) + 1, ack, 0, TH_SYN|TH_ACK, 0, 0,
		(u8 *) "\x02\x04\x05\xb4", 4,
		NULL, 0);
    sent++;
    tries++;

    /* Now it is time to wait for the response ... */
    to_usec = proxy-&gt;host.to.timeout;
    gettimeofday(&amp;tv_end, NULL);
    while((ipid == -1 || sent &gt; rcvd) &amp;&amp; to_usec &gt; 0) {

      to_usec = proxy-&gt;host.to.timeout - TIMEVAL_SUBTRACT(tv_end, tv_sent[tries-1]);
      if (to_usec &lt; 0) to_usec = 0; // Final no-block poll       ip = (struct ip *) readipv4_pcap(proxy-&gt;pd, &amp;bytes, to_usec, &amp;rcvdtime, NULL, true);
      gettimeofday(&amp;tv_end, NULL);
      if (ip) {
	if (bytes &lt; ( 4 * ip-&gt;ip_hl) + 14U)
	  continue;

	if (ip-&gt;ip_p == IPPROTO_TCP) {

	  tcp = ((struct tcp_hdr *) (((char *) ip) + 4 * ip-&gt;ip_hl));
	  if (ntohs(tcp-&gt;th_dport) &lt; base_port || ntohs(tcp-&gt;th_dport) - base_port &gt;= tries  || ntohs(tcp-&gt;th_sport) != proxy-&gt;probe_port || ((tcp-&gt;th_flags &amp; TH_RST) == 0)) {
	    if (ntohs(tcp-&gt;th_dport) &gt; o.magic_port &amp;&amp; ntohs(tcp-&gt;th_dport) &lt; (o.magic_port + 260)) { 	      if (o.debugging) { 		error("Received IP ID zombie probe response which probably came from an earlier prober instance ... increasing rttvar from %d to %d", 		      proxy-&gt;host.to.rttvar, (int) (proxy-&gt;host.to.rttvar * 1.2));
	      }
	      proxy-&gt;host.to.rttvar = (int) (proxy-&gt;host.to.rttvar * 1.2);
	      rcvd++;
	    }
	    else if (o.debugging &gt; 1) {
	      error("Received unexpected response packet from %s during IP ID zombie probing:", inet_ntoa(ip-&gt;ip_src));
	      readtcppacket( (unsigned char *) ip,MIN(ntohs(ip-&gt;ip_len), bytes));
	    }
	    continue;
	  }

	  trynum = ntohs(tcp-&gt;th_dport) - base_port;
	  rcvd++;

	  ipid = ntohs(ip-&gt;ip_id);
	  adjust_timeouts2(&amp;(tv_sent[trynum]), &amp;rcvdtime, &amp;(proxy-&gt;host.to));
	}
      }
    }
  } while(ipid == -1 &amp;&amp; tries &lt; maxtries);   if (probes_sent) *probes_sent = sent;   if (probes_rcvd) *probes_rcvd = rcvd;   return ipid; } /* Returns the number of increments between an early IP ID and a later    one, assuming the given IP ID Sequencing class.  Returns -1 if the    distance cannot be determined */ static int ipid_distance(int seqclass , u16 startid, u16 endid) {   if (seqclass == IPID_SEQ_INCR)     return endid - startid;   if (seqclass == IPID_SEQ_BROKEN_INCR) {     /* Convert to network byte order */     startid = htons(startid);     endid = htons(endid);     return endid - startid;   }   return -1; } static void initialize_proxy_struct(struct idle_proxy_info *proxy) {   proxy-&gt;seqclass = proxy-&gt;latestid = proxy-&gt;probe_port = 0;
  proxy-&gt;max_groupsz = proxy-&gt;min_groupsz = 0;
  proxy-&gt;current_groupsz = 0;
  proxy-&gt;senddelay = 0;
  proxy-&gt;max_senddelay = 0;
  proxy-&gt;pd = NULL;
  proxy-&gt;rawsd = -1;
  proxy-&gt;ethptr = NULL;
}

/* takes a proxy name/IP, resolves it if necessary, tests it for IP ID
   suitability, and fills out an idle_proxy_info structure.  If the
   proxy is determined to be unsuitable, the function whines and exits
   the program */
#define NUM_IPID_PROBES 6
static void initialize_idleproxy(struct idle_proxy_info *proxy, char *proxyName,
			  const struct in_addr *first_target, const struct scan_lists * ports) {
  int probes_sent = 0, probes_returned = 0;
  int hardtimeout = 9000000; /* Generally don't wait more than 9 secs total */
  unsigned int bytes, to_usec;
  int timedout = 0;
  char *p, *q;
  char *endptr = NULL;
  int seq_response_num;
  int newipid;
  int i;
  char filter[512]; /* Libpcap filter string */
  char name[MAXHOSTNAMELEN + 1];
  struct sockaddr_storage ss;
  size_t sslen;
  u32 sequence_base;
  u32 ack = 0;
  struct timeval probe_send_times[NUM_IPID_PROBES], tmptv, rcvdtime;
  u16 lastipid = 0;
  struct ip *ip;
  struct tcp_hdr *tcp;
  int distance;
  int ipids[NUM_IPID_PROBES];
  u8 probe_returned[NUM_IPID_PROBES];
  struct route_nfo rnfo;
  assert(proxy);
  assert(proxyName);

  ack = get_random_u32();

  for(i=0; i &lt; NUM_IPID_PROBES; i++) probe_returned[i] = 0;   initialize_proxy_struct(proxy);   initialize_timeout_info(&amp;proxy-&gt;host.to);

  proxy-&gt;max_groupsz = (o.max_parallelism)? o.max_parallelism : 100;
  proxy-&gt;min_groupsz = (o.min_parallelism)? o.min_parallelism : 4;
  proxy-&gt;max_senddelay = 100000;

  Strncpy(name, proxyName, sizeof(name));
  q = strchr(name, ':');
  if (q) {
    *q++ = '\0';
    proxy-&gt;probe_port = strtoul(q, &amp;endptr, 10);
    if (*q==0 || !endptr || *endptr != '\0' || !proxy-&gt;probe_port) {
      fatal("Invalid port number given in IP ID zombie specification: %s", proxyName);
    }
  } else {
    if (ports-&gt;syn_ping_count &gt; 0) {
      proxy-&gt;probe_port = ports-&gt;syn_ping_ports[0];
    } else if (ports-&gt;ack_ping_count &gt; 0) {
      proxy-&gt;probe_port = ports-&gt;ack_ping_ports[0];
    } else {
      u16 *ports;
      int count;

      getpts_simple(DEFAULT_TCP_PROBE_PORT_SPEC, SCAN_TCP_PORT, &amp;ports, &amp;count);
      assert(count &gt; 0);
      proxy-&gt;probe_port = ports[0];
      free(ports);
    }
  }

  proxy-&gt;host.setHostName(name);
  if (resolve(name, 0, 0, &amp;ss, &amp;sslen, o.pf()) == 0) {
    fatal("Could not resolve idle scan zombie host: %s", name);
  }
  proxy-&gt;host.setTargetSockAddr(&amp;ss, sslen);

  /* Lets figure out the appropriate source address to use when sending
     the pr0bez */
  proxy-&gt;host.TargetSockAddr(&amp;ss, &amp;sslen);
  if (!nmap_route_dst(&amp;ss, &amp;rnfo))
    fatal("Unable to find appropriate source address and device interface to use when sending packets to %s", proxyName);

  if (o.spoofsource) {
    o.SourceSockAddr(&amp;ss, &amp;sslen);
    proxy-&gt;host.setSourceSockAddr(&amp;ss, sslen);
    proxy-&gt;host.setDeviceNames(o.device, o.device);
  } else {
    proxy-&gt;host.setDeviceNames(rnfo.ii.devname, rnfo.ii.devfullname);
    proxy-&gt;host.setSourceSockAddr(&amp;rnfo.srcaddr, sizeof(rnfo.srcaddr));
  }
  if (rnfo.direct_connect) {
    proxy-&gt;host.setDirectlyConnected(true);
  } else {
    proxy-&gt;host.setDirectlyConnected(false);
    proxy-&gt;host.setNextHop(&amp;rnfo.nexthop,
			   sizeof(rnfo.nexthop));
  }
  proxy-&gt;host.setIfType(rnfo.ii.device_type);
  if (rnfo.ii.device_type == devt_ethernet)
    proxy-&gt;host.setSrcMACAddress(rnfo.ii.mac);

  /* Now lets send some probes to check IP ID algorithm ... */
  /* First we need a raw socket ... */
  if ((o.sendpref &amp; PACKET_SEND_ETH) &amp;&amp;  proxy-&gt;host.ifType() == devt_ethernet) {
    if (!setTargetNextHopMAC(&amp;proxy-&gt;host))
      fatal("%s: Failed to determine dst MAC address for Idle proxy",
	    __func__);
    memcpy(proxy-&gt;eth.srcmac, proxy-&gt;host.SrcMACAddress(), 6);
    memcpy(proxy-&gt;eth.dstmac, proxy-&gt;host.NextHopMACAddress(), 6);
    proxy-&gt;eth.ethsd = eth_open_cached(proxy-&gt;host.deviceName());
    if (proxy-&gt;eth.ethsd == NULL)
      fatal("%s: Failed to open ethernet device (%s)", __func__, proxy-&gt;host.deviceName());
    proxy-&gt;rawsd = -1;
    proxy-&gt;ethptr = &amp;proxy-&gt;eth;
  } else {
#ifdef WIN32
    win32_fatal_raw_sockets(proxy-&gt;host.deviceName());
#endif
    if ((proxy-&gt;rawsd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; 0 )       pfatal("socket troubles in %s", __func__);     unblock_socket(proxy-&gt;rawsd);
    broadcast_socket(proxy-&gt;rawsd);
#ifndef WIN32
    sethdrinclude(proxy-&gt;rawsd);
#endif
    proxy-&gt;eth.ethsd = NULL;
    proxy-&gt;ethptr = NULL;
  }

/* Now for the pcap opening nonsense ... */
 /* Note that the snaplen is 152 = 64 byte max IPhdr + 24 byte max link_layer
  * header + 64 byte max TCP header. */
  if((proxy-&gt;pd=my_pcap_open_live(proxy-&gt;host.deviceName(), 152,  (o.spoofsource)? 1 : 0, 50))==NULL)
    fatal("%s", PCAP_OPEN_ERRMSG);

  p = strdup(proxy-&gt;host.targetipstr());
  q = strdup(inet_ntoa(proxy-&gt;host.v4source()));
  Snprintf(filter, sizeof(filter), "tcp and src host %s and dst host %s and src port %hu", p, q, proxy-&gt;probe_port);
 free(p);
 free(q);
 set_pcap_filter(proxy-&gt;host.deviceFullName(), proxy-&gt;pd,  filter);
 if (o.debugging)
   log_write(LOG_STDOUT, "Packet capture filter (device %s): %s\n", proxy-&gt;host.deviceFullName(), filter);
/* Windows nonsense -- I am not sure why this is needed, but I should
   get rid of it at sometime */

 sequence_base = get_random_u32();

 /* Yahoo!  It is finally time to send our pr0beZ! */

  while(probes_sent &lt; NUM_IPID_PROBES) {     if (o.scan_delay) enforce_scan_delay(NULL);     else if (probes_sent) usleep(30000);     /* TH_SYN|TH_ACK is what the proxy will really be receiving from        the target, and is more likely to get through firewalls.  But        TH_SYN allows us to get a nonzero ACK back so we can associate        a response with the exact request for timing purposes.  So I        think I'll use TH_SYN, although it is a tough call. */     /* We can't use decoys 'cause that would screw up the IP IDs */     send_tcp_raw(proxy-&gt;rawsd, proxy-&gt;ethptr,
    		proxy-&gt;host.v4sourceip(), proxy-&gt;host.v4hostip(),
    		o.ttl, false,
    		o.ipoptions, o.ipoptionslen,
		 o.magic_port + probes_sent + 1, proxy-&gt;probe_port,
		sequence_base + probes_sent + 1, ack, 0, TH_SYN|TH_ACK, 0, 0,
		(u8 *) "\x02\x04\x05\xb4",4,
		NULL, 0);
    gettimeofday(&amp;probe_send_times[probes_sent], NULL);
    probes_sent++;

    /* Time to collect any replies */
    while(probes_returned &lt; probes_sent &amp;&amp; !timedout) {       to_usec = (probes_sent == NUM_IPID_PROBES)? hardtimeout : 1000;       ip = (struct ip *) readipv4_pcap(proxy-&gt;pd, &amp;bytes, to_usec, &amp;rcvdtime, NULL, true);

      gettimeofday(&amp;tmptv, NULL);

      if (!ip) {
	if (probes_sent &lt; NUM_IPID_PROBES) 	  break; 	if (TIMEVAL_SUBTRACT(tmptv, probe_send_times[probes_sent - 1]) &gt;= hardtimeout) {
	  timedout = 1;
	}
	continue;
      } else if (TIMEVAL_SUBTRACT(tmptv, probe_send_times[probes_sent - 1]) &gt;=
		 hardtimeout)  {
	timedout = 1;
      }

      if (lastipid != 0 &amp;&amp; ip-&gt;ip_id == lastipid) {
	continue; /* probably a duplicate */
      }
      lastipid = ip-&gt;ip_id;

      if (bytes &lt; ( 4 * ip-&gt;ip_hl) + 14U)
	continue;

      if (ip-&gt;ip_p == IPPROTO_TCP) {
	tcp = ((struct tcp_hdr *) (((char *) ip) + 4 * ip-&gt;ip_hl));
	if (ntohs(tcp-&gt;th_dport) &lt; (o.magic_port+1) || ntohs(tcp-&gt;th_dport) - o.magic_port &gt; NUM_IPID_PROBES  || ntohs(tcp-&gt;th_sport) != proxy-&gt;probe_port || ((tcp-&gt;th_flags &amp; TH_RST) == 0)) {
	  if (o.debugging &gt; 1) error("Received unexpected response packet from %s during initial IP ID zombie testing", inet_ntoa(ip-&gt;ip_src));
	  continue;
	}

	seq_response_num = probes_returned;

	/* The stuff below only works when we send SYN packets instead of
	   SYN|ACK, but then are slightly less stealthy and have less chance
	   of sneaking through the firewall.  Plus SYN|ACK is what they will
	   be receiving back from the target */
	probes_returned++;
	ipids[seq_response_num] = (u16) ntohs(ip-&gt;ip_id);
	probe_returned[seq_response_num] = 1;
	adjust_timeouts2(&amp;probe_send_times[seq_response_num], &amp;rcvdtime, &amp;(proxy-&gt;host.to));
      }
    }
  }

  /* Yeah!  We're done sending/receiving probes ... now lets ensure all of our responses are adjacent in the array */
  for(i=0,probes_returned=0; i &lt; NUM_IPID_PROBES; i++) {     if (probe_returned[i]) {       if (i &gt; probes_returned)
	ipids[probes_returned] = ipids[i];
      probes_returned++;
    }
  }

  if (probes_returned == 0)
    fatal("Idle scan zombie %s (%s) port %hu cannot be used because it has not returned any of our probes -- perhaps it is down or firewalled.",
	  proxy-&gt;host.HostName(), proxy-&gt;host.targetipstr(),
	  proxy-&gt;probe_port);

  proxy-&gt;seqclass = get_ipid_sequence(probes_returned, ipids, 0);
  switch(proxy-&gt;seqclass) {
  case IPID_SEQ_INCR:
  case IPID_SEQ_BROKEN_INCR:
    log_write(LOG_PLAIN, "Idle scan using zombie %s (%s:%hu); Class: %s\n", proxy-&gt;host.HostName(), proxy-&gt;host.targetipstr(), proxy-&gt;probe_port, ipidclass2ascii(proxy-&gt;seqclass));
    break;
  default:
    fatal("Idle scan zombie %s (%s) port %hu cannot be used because IP ID sequencability class is: %s.  Try another proxy.", proxy-&gt;host.HostName(), proxy-&gt;host.targetipstr(), proxy-&gt;probe_port, ipidclass2ascii(proxy-&gt;seqclass));
  }

  proxy-&gt;latestid = ipids[probes_returned - 1];
  proxy-&gt;current_groupsz = MIN(proxy-&gt;max_groupsz, 30);

  if (probes_returned &lt; NUM_IPID_PROBES) {     /* Yikes!  We're already losing packets ... clamp down a bit ... */     if (o.debugging)       error("Idle scan initial zombie qualification test: %d probes sent, only %d returned", NUM_IPID_PROBES, probes_returned);     proxy-&gt;current_groupsz = MIN(12, proxy-&gt;max_groupsz);
    proxy-&gt;current_groupsz = MAX(proxy-&gt;current_groupsz, proxy-&gt;min_groupsz);
    proxy-&gt;senddelay += 5000;
  }

  /* OK, through experimentation I have found that some hosts (*cough*
   Solaris) APPEAR to use simple IP ID incrementing, but in reality they
   assign a new IP ID base to each host which connects with them.  This
   is actually a good idea on several fronts, but it totally
   frustrates our efforts (which rely on side-channel IP ID info
   leaking to different hosts).  The good news is that we can easily
   detect the problem by sending some spoofed packets "from" the first
   target to the zombie and then probing to verify that the proxy IP ID
   changed.  This will also catch the case where the Nmap user is
   behind an egress filter or other measure that prevents this sort of
   sp00fery */
  if (first_target) {
    for (probes_sent = 0; probes_sent &lt; 4; probes_sent++) {       if (probes_sent) usleep(50000);       send_tcp_raw(proxy-&gt;rawsd, proxy-&gt;ethptr,
      		first_target, proxy-&gt;host.v4hostip(),
		o.ttl, false,
		o.ipoptions, o.ipoptionslen,
		o.magic_port, proxy-&gt;probe_port,
		sequence_base + probes_sent + 1, ack, 0, TH_SYN|TH_ACK, 0, 0,
		(u8 *) "\x02\x04\x05\xb4",
		4, NULL, 0);

    }

    /* Sleep a little while to give packets time to reach their destination */
    usleep(300000);
    newipid = ipid_proxy_probe(proxy, NULL, NULL);
    if (newipid == -1)
      newipid = ipid_proxy_probe(proxy, NULL, NULL); /* OK, we'll give it one more try */

    if (newipid &lt; 0) fatal("Your IP ID Zombie (%s; %s) is behaving strangely -- suddenly cannot obtain IP ID", proxy-&gt;host.HostName(), proxy-&gt;host.targetipstr());

    distance = ipid_distance(proxy-&gt;seqclass, proxy-&gt;latestid, newipid);
    if (distance &lt;= 0) {       fatal("Your IP ID Zombie (%s; %s) is behaving strangely -- suddenly cannot obtain valid IP ID distance.", proxy-&gt;host.HostName(), proxy-&gt;host.targetipstr());
    } else if (distance == 1) {
      fatal("Even though your Zombie (%s; %s) appears to be vulnerable to IP ID sequence prediction (class: %s), our attempts have failed.  This generally means that either the zombie uses a separate IP ID base for each host (like Solaris), or because you cannot spoof IP packets (perhaps your ISP has enabled egress filtering to prevent IP spoofing), or maybe the target network recognizes the packet source as bogus and drops them", proxy-&gt;host.HostName(), proxy-&gt;host.targetipstr(), ipidclass2ascii(proxy-&gt;seqclass));
    }
    if (o.debugging &amp;&amp; distance != 5) {
      error("WARNING: IP ID spoofing test sent 4 packets and expected a distance of 5, but instead got %d", distance);
    }
    proxy-&gt;latestid = newipid;
  }

}

/* Adjust timing parameters up or down given that an idle scan found a
   count of 'testcount' while the 'realcount' is as given.  If the
   testcount was correct, timing is made more aggressive, while it is
   slowed down in the case of an error */
static void adjust_idle_timing(struct idle_proxy_info *proxy,
			Target *target, int testcount,
			int realcount) {

  static int notidlewarning = 0;

  if (o.debugging &gt; 1)
    log_write(LOG_STDOUT,
	  "%s: tested/true %d/%d -- old grpsz/delay: %f/%d ",
	  __func__, testcount, realcount, proxy-&gt;current_groupsz, proxy-&gt;senddelay);
  else if (o.debugging &amp;&amp; testcount != realcount) {
    error("%s: testcount: %d  realcount: %d -- old grpsz/delay: %f/%d", __func__, testcount, realcount, proxy-&gt;current_groupsz, proxy-&gt;senddelay);
  }

    if (testcount &lt; realcount) {       /* We must have missed a port -- our probe could have been 	 dropped, the response to proxy could have been dropped, or we 	 didn't wait long enough before probing the proxy IP ID.  The 	 third case is covered elsewhere in the scan, so we worry most 	 about the first two.  The solution is to decrease our group 	 size and add a sending delay */ /* packets could be dropped because too many were sent at once */       proxy-&gt;current_groupsz = MAX(proxy-&gt;min_groupsz, proxy-&gt;current_groupsz * 0.8);
      proxy-&gt;senddelay += 10000;
      proxy-&gt;senddelay = MIN(proxy-&gt;max_senddelay, proxy-&gt;senddelay);
       /* No group size should be greater than .5s of send delays */
      proxy-&gt;current_groupsz = MAX(proxy-&gt;min_groupsz, MIN(proxy-&gt;current_groupsz, 500000 / (proxy-&gt;senddelay + 1)));

    } else if (testcount &gt; realcount) {
      /* Perhaps the proxy host is not really idle ... */
      /* I guess all I can do is decrease the group size, so that if the proxy is not really idle, at least we may be able to scan chunks more quickly in between outside packets */
      proxy-&gt;current_groupsz = MAX(proxy-&gt;min_groupsz, proxy-&gt;current_groupsz * 0.8);

      if (!notidlewarning &amp;&amp; o.verbose) {
	notidlewarning = 1;
	error("WARNING: idle scan has erroneously detected phantom ports -- is the proxy %s (%s) really idle?", proxy-&gt;host.HostName(), proxy-&gt;host.targetipstr());
      }
    } else {
      /* W00p We got a perfect match.  That means we get a slight increase
	 in allowed group size and we can lightly decrease the senddelay */

      proxy-&gt;senddelay = (int) (proxy-&gt;senddelay * 0.9);
      if (proxy-&gt;senddelay &lt; 500) proxy-&gt;senddelay = 0;
      proxy-&gt;current_groupsz = MIN(proxy-&gt;current_groupsz * 1.1, 500000 / (proxy-&gt;senddelay + 1));
      proxy-&gt;current_groupsz = MIN(proxy-&gt;max_groupsz, proxy-&gt;current_groupsz);

    }
    if (o.debugging &gt; 1)
      log_write(LOG_STDOUT, "-&gt; %f/%d\n", proxy-&gt;current_groupsz, proxy-&gt;senddelay);
}

/* OK, now this is the hardcore idle scan function which actually does
   the testing (most of the other cruft in this file is just
   coordination, preparation, etc).  This function simply uses the
   idle scan technique to try and count the number of open ports in the
   given port array.  The sent_time and rcv_time are filled in with
   the times that the probe packet &amp; response were sent/received.
   They can be NULL if you don't want to use them.  The purpose is for
   timing adjustments if the numbers turn out to be accurate. */

static int idlescan_countopen2(struct idle_proxy_info *proxy,
			Target *target, u16 *ports, int numports,
			struct timeval *sent_time, struct timeval *rcv_time)
{

#if 0 /* Testing code */
  int i;
  for(i=0; i &lt; numports; i++)     if (ports[i] == 22)       return 1;   return 0; #endif   int openports;   int tries;   int proxyprobes_sent = 0; /* diff. from tries 'cause sometimes we 			       skip tries */   int proxyprobes_rcvd = 0; /* To determine if packets were dr0pped */   int sent, rcvd;   int ipid_dist;   struct timeval start, end, latestchange, now;   struct timeval probe_times[4];   int pr0be;   static u32 seq = 0;   int newipid = 0;   int sleeptime;   int lasttry = 0;   int dotry3 = 0;   struct eth_nfo eth;   if (seq == 0) seq = get_random_u32();   memset(&amp;end, 0, sizeof(end));   memset(&amp;latestchange, 0, sizeof(latestchange));   gettimeofday(&amp;start, NULL);   if (sent_time) memset(sent_time, 0, sizeof(*sent_time));   if (rcv_time) memset(rcv_time, 0, sizeof(*rcv_time));   if (proxy-&gt;rawsd &lt; 0) {     if (!setTargetNextHopMAC(target))       fatal("%s: Failed to determine dst MAC address for Idle proxy", 	    __func__);     memcpy(eth.srcmac, target-&gt;SrcMACAddress(), 6);
    memcpy(eth.dstmac, target-&gt;NextHopMACAddress(), 6);
    eth.ethsd = eth_open_cached(target-&gt;deviceName());
    if (eth.ethsd == NULL)
      fatal("%s: Failed to open ethernet device (%s)", __func__, target-&gt;deviceName());
  } else eth.ethsd = NULL;

  /* I start by sending out the SYN pr0bez */
  for(pr0be = 0; pr0be &lt; numports; pr0be++) {     if (o.scan_delay) enforce_scan_delay(NULL);     else if (proxy-&gt;senddelay &amp;&amp; pr0be &gt; 0) usleep(proxy-&gt;senddelay);

    /* Maybe I should involve decoys in the picture at some point --
       but doing it the straightforward way (using the same decoys as
       we use in probing the proxy box is risky.  I'll have to think
       about this more. */
    send_tcp_raw(proxy-&gt;rawsd, eth.ethsd? &amp;eth : NULL,
    		proxy-&gt;host.v4hostip(), target-&gt;v4hostip(),
		o.ttl, false,
		o.ipoptions, o.ipoptionslen,
		proxy-&gt;probe_port, ports[pr0be], seq, 0, 0, TH_SYN, 0, 0,
		(u8 *) "\x02\x04\x05\xb4", 4,
		o.extra_payload, o.extra_payload_length);
  }
  gettimeofday(&amp;end, NULL);

  openports = -1;
  tries = 0;
  TIMEVAL_MSEC_ADD(probe_times[0], start, MAX(50, (target-&gt;to.srtt * 3/4) / 1000));
  TIMEVAL_MSEC_ADD(probe_times[1], start, target-&gt;to.srtt / 1000 );
  TIMEVAL_MSEC_ADD(probe_times[2], end, MAX(75, (2 * target-&gt;to.srtt +
						   target-&gt;to.rttvar) / 1000));
  TIMEVAL_MSEC_ADD(probe_times[3], end, MIN(4000, (2 * target-&gt;to.srtt +
						     (target-&gt;to.rttvar &lt;&lt; 2 )) / 1000));   do {     if (tries == 2) dotry3 = (get_random_u8() &gt; 200);
    if (tries == 3 &amp;&amp; !dotry3)
      break; /* We usually want to skip the long-wait test */
    if (tries == 3 || (tries == 2 &amp;&amp; !dotry3))
      lasttry = 1;

    gettimeofday(&amp;now, NULL);
    sleeptime = TIMEVAL_SUBTRACT(probe_times[tries], now);
    if (!lasttry &amp;&amp; proxyprobes_sent &gt; 0 &amp;&amp; sleeptime &lt; 50000)
      continue; /* No point going again so soon */

    if (tries == 0 &amp;&amp; sleeptime &lt; 500)       sleeptime = 500;     if (o.debugging &gt; 1) error("In preparation for idle scan probe try #%d, sleeping for %d usecs", tries, sleeptime);
    if (sleeptime &gt; 0)
      usleep(sleeptime);

    newipid = ipid_proxy_probe(proxy, &amp;sent, &amp;rcvd);
    proxyprobes_sent += sent;
    proxyprobes_rcvd += rcvd;

    if (newipid &gt; 0) {
      ipid_dist = ipid_distance(proxy-&gt;seqclass, proxy-&gt;latestid, newipid);
      /* I used to only do this if ipid_sit &gt;= proxyprobes_sent, but I'd
	 rather have a negative number in that case. */
      if (ipid_dist &lt; proxyprobes_sent) { 	if (o.debugging)            error("%s: Must have lost a sent packet because ipid_dist is %d while proxyprobes_sent is %d.", __func__, ipid_dist, proxyprobes_sent); 	/* I no longer whack timing here ... done at bottom. */       }       ipid_dist -= proxyprobes_sent;       if (ipid_dist &gt; openports) {
	openports = ipid_dist;
	gettimeofday(&amp;latestchange, NULL);
      } else if (ipid_dist &lt; openports &amp;&amp; ipid_dist &gt;= 0) {
	/* Uh-oh.  Perhaps I dropped a packet this time */
	if (o.debugging &gt; 1) {
	  error("%s: Counted %d open ports in try #%d, but counted %d earlier ... probably a proxy_probe problem", __func__, ipid_dist, tries, openports);
	}
	/* I no longer whack timing here ... done at bottom. */
      }
    }

    if (openports &gt; numports || (numports &lt;= 2 &amp;&amp; (openports == numports)))
      break;
  } while(tries++ &lt; 3);   if (proxyprobes_sent &gt; proxyprobes_rcvd) {
    /* Uh-oh.  It looks like we lost at least one proxy probe packet */
    if (o.debugging) {
      error("%s: Sent %d probes; only %d responses.  Slowing scan.", __func__, proxyprobes_sent, proxyprobes_rcvd);
    }
    proxy-&gt;senddelay += 5000;
    proxy-&gt;senddelay = MIN(proxy-&gt;max_senddelay, proxy-&gt;senddelay);
    /* No group size should be greater than .5s of send delays */
    proxy-&gt;current_groupsz = MAX(proxy-&gt;min_groupsz, MIN(proxy-&gt;current_groupsz, 500000 / (proxy-&gt;senddelay+1)));
  } else {
    /* Yeah, we got as many responses as we sent probes.  This calls for a
       very light timing acceleration ... */
    proxy-&gt;senddelay = (int) (proxy-&gt;senddelay * 0.95);
    if (proxy-&gt;senddelay &lt; 500) proxy-&gt;senddelay = 0;
    proxy-&gt;current_groupsz = MAX(proxy-&gt;min_groupsz, MIN(proxy-&gt;current_groupsz, 500000 / (proxy-&gt;senddelay+1)));
  }

  if ((openports &gt; 0) &amp;&amp; (openports &lt;= numports)) {     /* Yeah, we found open ports... lets adjust the timing ... */     if (o.debugging &gt; 2) error("%s:  found %d open ports (out of %d) in %lu usecs", __func__, openports, numports, (unsigned long) TIMEVAL_SUBTRACT(latestchange, start));
    if (sent_time) *sent_time = start;
    if (rcv_time) *rcv_time = latestchange;
  }
  if (newipid &gt; 0) proxy-&gt;latestid = newipid;
  if (eth.ethsd) { eth.ethsd = NULL; } /* don't need to close it due to caching */
  return openports;
}

/* The job of this function is to use the idle scan technique to count
   the number of open ports in the given list.  Under the covers, this
   function just farms out the hard work to another function. */
static int idlescan_countopen(struct idle_proxy_info *proxy,
		       Target *target, u16 *ports, int numports,
		       struct timeval *sent_time, struct timeval *rcv_time) {
  int tries = 0;
  int openports;

  do {
    openports = idlescan_countopen2(proxy, target, ports, numports, sent_time,
				    rcv_time);
    tries++;
    if (tries == 6 || (openports &gt;= 0 &amp;&amp; openports &lt;= numports))       break;     if (o.debugging) {       error("%s: In try #%d, counted %d open ports out of %d.  Retrying", __func__, tries, openports, numports);     }     /* Sleep for a little while -- maybe proxy host had brief birst of        traffic or similar problem */     sleep(tries * tries);     if (tries == 5)       sleep(45); /* We're gonna give up if this fails, so we will be a bit 		    patient */     /* Since the host may have received packets while we were sleeping,        lets update our proxy IP ID counter */     proxy-&gt;latestid = ipid_proxy_probe(proxy, NULL, NULL);
  } while(1);

  if (openports &lt; 0 || openports &gt; numports ) {
    /* Oh f*ck!!!! */
    fatal("Idle scan is unable to obtain meaningful results from proxy %s (%s).  I'm sorry it didn't work out.", proxy-&gt;host.HostName(),
	  proxy-&gt;host.targetipstr());
  }

  if (o.debugging &gt; 2) error("%s: %d ports found open out of %d, starting with %hu", __func__, openports, numports, ports[0]);

  return openports;
}

/* Recursively idle scans scans a group of ports using a depth-first
   divide-and-conquer strategy to find the open one(s). */

static int idle_treescan(struct idle_proxy_info *proxy, Target *target,
		 u16 *ports, int numports, int expectedopen) {

  int firstHalfSz = (numports + 1)/2;
  int secondHalfSz = numports - firstHalfSz;
  int flatcount1, flatcount2;
  int deepcount1 = -1, deepcount2 = -1;
  struct timeval sentTime1, rcvTime1, sentTime2, rcvTime2;
  int retrycount = -1, retry2 = -1;
  int totalfound = 0;
  /* Scan the first half of the range */

  if (o.debugging &gt; 1) {
    error("%s: Called against %s with %d ports, starting with %hu. expectedopen: %d", __func__, target-&gt;targetipstr(), numports, ports[0], expectedopen);
    error("IDLE SCAN TIMING: grpsz: %.3f delay: %d srtt: %d rttvar: %d",
	  proxy-&gt;current_groupsz, proxy-&gt;senddelay, target-&gt;to.srtt,
	  target-&gt;to.rttvar);
  }

  flatcount1 = idlescan_countopen(proxy, target, ports, firstHalfSz,
				  &amp;sentTime1, &amp;rcvTime1);

  if (firstHalfSz &gt; 1 &amp;&amp; flatcount1 &gt; 0) {
    /* A port appears open!  We dig down deeper to find it ... */
    deepcount1 = idle_treescan(proxy, target, ports, firstHalfSz, flatcount1);
    /* Now we assume deepcount1 is right, and adjust timing if flatcount1 was
       wrong. */
    adjust_idle_timing(proxy, target, flatcount1, deepcount1);
  }

  /* I guess we had better do the second half too ... */

  flatcount2 = idlescan_countopen(proxy, target, ports + firstHalfSz,
				  secondHalfSz, &amp;sentTime2, &amp;rcvTime2);

  if ((secondHalfSz) &gt; 1 &amp;&amp; flatcount2 &gt; 0) {
    /* A port appears open!  We dig down deeper to find it ... */
    deepcount2 = idle_treescan(proxy, target, ports + firstHalfSz,
			       secondHalfSz, flatcount2);
    /* Now we assume deepcount1 is right, and adjust timing if flatcount1 was
       wrong */
    adjust_idle_timing(proxy, target, flatcount2, deepcount2);
  }

  totalfound = (deepcount1 == -1)? flatcount1 : deepcount1;
  totalfound += (deepcount2 == -1)? flatcount2 : deepcount2;

  if ((flatcount1 + flatcount2 == totalfound) &amp;&amp;
      (expectedopen == totalfound || expectedopen == -1)) {

    if (flatcount1 &gt; 0) {
      if (o.debugging &gt; 1) {
	error("Adjusting timing -- idlescan_countopen correctly found %d open ports (out of %d, starting with %hu)", flatcount1, firstHalfSz, ports[0]);
      }
      adjust_timeouts2(&amp;sentTime1, &amp;rcvTime1, &amp;(target-&gt;to));
    }

    if (flatcount2 &gt; 0) {
      if (o.debugging &gt; 2) {
	error("Adjusting timing -- idlescan_countopen correctly found %d open ports (out of %d, starting with %hu)", flatcount2, secondHalfSz,
	      ports[firstHalfSz]);
      }
      adjust_timeouts2(&amp;sentTime2, &amp;rcvTime2, &amp;(target-&gt;to));
    }
  }

  if (totalfound != expectedopen) {
    if (deepcount1 == -1) {
      retrycount = idlescan_countopen(proxy, target, ports, firstHalfSz, NULL,
				      NULL);
      if (retrycount != flatcount1) {
	/* We have to do a deep count if new ports were found and
	   there are more than 1 total */
	if (firstHalfSz &gt; 1 &amp;&amp; retrycount &gt; 0) {
	  retry2 = retrycount;
	  retrycount = idle_treescan(proxy, target, ports, firstHalfSz,
				     retrycount);
	  adjust_idle_timing(proxy, target, retry2, retrycount);
	} else {
	  if (o.debugging)
	    error("Adjusting timing because my first scan of %d ports, starting with %hu found %d open, while second scan yielded %d", firstHalfSz, ports[0], flatcount1, retrycount);
	  adjust_idle_timing(proxy, target, flatcount1, retrycount);
	}
	totalfound += retrycount - flatcount1;
	flatcount1 = retrycount;

	/* If our first count erroneously found and added an open port,
	   we must delete it */
	if (firstHalfSz == 1 &amp;&amp; flatcount1 == 1 &amp;&amp; retrycount == 0)
	  target-&gt;ports.forgetPort(ports[0], IPPROTO_TCP);

      }
    }

    if (deepcount2 == -1) {
      retrycount = idlescan_countopen(proxy, target, ports + firstHalfSz,
				      secondHalfSz, NULL, NULL);
      if (retrycount != flatcount2) {
	if (secondHalfSz &gt; 1 &amp;&amp; retrycount &gt; 0) {
	  retry2 = retrycount;
	  retrycount = idle_treescan(proxy, target, ports + firstHalfSz,
				     secondHalfSz, retrycount);
	  adjust_idle_timing(proxy, target, retry2, retrycount);
	} else {
	  if (o.debugging)
	    error("Adjusting timing because my first scan of %d ports, starting with %hu found %d open, while second scan yeilded %d", secondHalfSz, ports[firstHalfSz], flatcount2, retrycount);
	  adjust_idle_timing(proxy, target, flatcount2, retrycount);
	}

	totalfound += retrycount - flatcount2;
	flatcount2 = retrycount;

	/* If our first count erroneously found and added an open port,
	   we must delete it. */
	if (secondHalfSz == 1 &amp;&amp; flatcount2 == 1 &amp;&amp; retrycount == 0)
	  target-&gt;ports.forgetPort(ports[firstHalfSz], IPPROTO_TCP);

      }
    }
  }

  if (firstHalfSz == 1 &amp;&amp; flatcount1 == 1)
    target-&gt;ports.setPortState(ports[0], IPPROTO_TCP, PORT_OPEN);

  if ((secondHalfSz == 1) &amp;&amp; flatcount2 == 1)
    target-&gt;ports.setPortState(ports[firstHalfSz], IPPROTO_TCP, PORT_OPEN);
  return totalfound;

}

/* The very top-level idle scan function -- scans the given target
   host using the given proxy -- the proxy is cached so that you can keep
   calling this function with different targets. */
void idle_scan(Target *target, u16 *portarray, int numports,
	       char *proxyName, const struct scan_lists * ports) {

  static char lastproxy[MAXHOSTNAMELEN + 1] = ""; /* The proxy used in any previous call */
  static struct idle_proxy_info proxy;
  int groupsz;
  int portidx = 0; /* Used for splitting the port array into chunks */
  int portsleft;
  char scanname[128];
  Snprintf(scanname, sizeof(scanname), "idle scan against %s", target-&gt;NameIP());
  ScanProgressMeter SPM(scanname);

  if (numports == 0) return; /* nothing to scan for */
  if (!proxyName) fatal("idle scan requires a proxy host");

  if (*lastproxy &amp;&amp; strcmp(proxyName, lastproxy))
    fatal("%s: You are not allowed to change proxies midstream.  Sorry", __func__);
  assert(target);

  if (target-&gt;timedOut(NULL))
    return;

  if (target-&gt;ifType() == devt_loopback) {
    log_write(LOG_STDOUT, "Skipping Idle Scan against %s -- you can't idle scan your own machine (localhost).\n", target-&gt;NameIP());
    return;
  }

  target-&gt;startTimeOutClock(NULL);

  /* If this is the first call,  */
  if (!*lastproxy) {
    initialize_idleproxy(&amp;proxy, proxyName, target-&gt;v4hostip(), ports);
    strncpy(lastproxy, proxyName, sizeof(lastproxy));
  }

  /* If we don't have timing infoz for the new target, we'll use values
     derived from the proxy */
  if (target-&gt;to.srtt == -1 &amp;&amp; target-&gt;to.rttvar == -1) {
    target-&gt;to.srtt = MAX(200000,2 * proxy.host.to.srtt);
    target-&gt;to.rttvar = MAX(10000, MIN(proxy.host.to.rttvar, 2000000));
    target-&gt;to.timeout = target-&gt;to.srtt + (target-&gt;to.rttvar &lt;&lt; 2);   } else {     target-&gt;to.srtt = MAX(target-&gt;to.srtt, proxy.host.to.srtt);
    target-&gt;to.rttvar = MAX(target-&gt;to.rttvar, proxy.host.to.rttvar);
    target-&gt;to.timeout = target-&gt;to.srtt + (target-&gt;to.rttvar &lt;&lt; 2);
  }

  /* Now I guess it is time to let the scanning begin!  Since idle
     scan is sort of tree structured (we scan a group and then divide
     it up and drill down in subscans of the group), we split the port
     space into smaller groups and then call a recursive
     divide-and-counquer function to find the open ports */
  while(portidx &lt; numports) {
    portsleft = numports - portidx;
    /* current_groupsz is doubled below because idle_subscan cuts in half */
    groupsz = MIN(portsleft, (int) (proxy.current_groupsz * 2));
    idle_treescan(&amp;proxy, target, portarray + portidx, groupsz, -1);
    portidx += groupsz;
  }

  char additional_info[14];
  Snprintf(additional_info, sizeof(additional_info), "%d ports", numports);
  SPM.endTask(NULL, additional_info);

  /* Now we go through the ports which were scanned but not determined
     to be open, and add them in the "closed|filtered" state */
  for(portidx = 0; portidx &lt; numports; portidx++) {     if (target-&gt;ports.portIsDefault(portarray[portidx], IPPROTO_TCP)) {
      target-&gt;ports.setPortState(portarray[portidx], IPPROTO_TCP, PORT_CLOSEDFILTERED);
      target-&gt;ports.setStateReason(portarray[portidx], IPPROTO_TCP, ER_NOIPIDCHANGE, 0, NULL);
    } else
      target-&gt;ports.setStateReason(portarray[portidx], IPPROTO_TCP, ER_IPIDCHANGE, 0, NULL);
  }

  target-&gt;stopTimeOutClock(NULL);
  return;
}
</pre>
<p>As you can see, this is my screenshot of the C++ source file. Just compile it and run it to get the results.</p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh28.png" alt=""></p>
<p>OK, let’s start with our original scan method.</p>
<p><strong>IP Protocol Scan</strong></p>
<p>IP protocol scan allows you to determine which IP protocols (TCP, ICMP, IGMP, etc.) are supported by target machines. This isn’t technically a port scan, since it cycles through IP protocol numbers rather than TCP or UDP port numbers.</p>
<p><strong>Command: nmap –sO target</strong></p>
<p><img src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/051914_1336_NmapCheatSh29.png" alt=""></p>
<p><strong>FTP Bounce Scan</strong></p>
<p>This allows a user to connect to one FTP server, then ask that files be sent to a third-party server. Simply it asks the FTP server to send a file to each interesting port of a target host in turn. The error message will describe whether the port is open or not. This is a good way to bypass firewalls, because organizational FTP servers are often placed where they have more access to other internal hosts than any old Internet host would. It takes an argument of the form &lt;username&gt;:&lt;password&gt;@&lt;server&gt;:&lt;port&gt;. &lt;Server&gt; is the name or IP address of a vulnerable FTP server.</p>
<p><strong>Command: nmap –b ftp rely host.</strong> Also, this can be used for port bounce attack.</p>
<p><strong>nmap -T0 -b username:password@ftpserver.tld:21 victim.tld</strong></p>
<p>This uses the username “username”, the password “password”, the FTP server “ftpserver.tld” and port 21 on said server to scan victim.tld.</p>
<p>If the FTP server supports anonymous logins, just forget about the username:password@ part and Nmap will assume it allows -anonymous. You may omit :21 if the FTP port is 21, however, some people configure FTP on weird ports as an attempt at “security”.</p>
<p><strong>Port Specification and Scan Order</strong></p>
<p>In addition to all of the scan methods discussed previously, Nmap offers options for specifying which ports are scanned and whether the scan order is randomized or sequential. By default, Nmap scans the most common 1,000 ports for each protocol.</p>
<p>-p &lt;port ranges&gt; (Only scan specified ports)</p>
<p>This option specifies which ports you want to scan and overrides the default. Individual port numbers are OK, as are ranges separated by a hyphen (e.g. 1-1023). The beginning and/or end values of a range may be omitted, causing Nmap to use 1 and 65535, respectively. So you can specify -p- to scan ports from 1 through 65535. Scanning port zero is allowed if you specify it explicitly.</p>
<p>Nmap –p 1-1023 target</p>
<p>When scanning a combination of protocols (e.g. TCP and UDP), you can specify a particular protocol by preceding the port numbers by T: for TCP, U: for UDP, S: for SCTP, or P: for IP Protocol.</p>
<p>nmap -p U:53,111,137,T:21-25,80,139,8080 target</p>
<p><strong>-F (Fast (limited port) scan)</strong></p>
<p>Specifies that you wish to scan fewer ports than the default. Normally Nmap scans the most common 1,000 ports for each scanned protocol. With -F, this is reduced to 100.</p>
<p><strong>nmap –F target</strong></p>
<p><strong>-r (Don’t randomize ports)</strong></p>
<p>By default, Nmap randomizes the scanned port order (except that certain commonly accessible ports are moved near the beginning for efficiency reasons). This randomization is normally desirable, but you can specify -r for sequential (sorted from lowest to highest) port scanning instead.</p>
<p>nmap –r target</p>
<p>So this is the end of this part of the series. In the next part, I will go through advanced firewall evasion and custom creation of exploits with Nmap.</p>
<p><strong>Warning: The above mentioned malicious attack conducted on the lab has been given prior permission by the owner of website or admin. The above is meant for only educational purposes. So do not use for any personal intent, as it is prone to cyber attack.</strong></p>
<p><strong>References:</strong></p>
<p><a href="http://www.kyuzz.org/antirez/papers/dumbscan.html" onclick="__gaTracker(&#39;send&#39;, &#39;event&#39;, &#39;outbound-article&#39;, &#39;http://www.kyuzz.org/antirez/papers/dumbscan.html&#39;, &#39;http://www.kyuzz.org/antirez/papers/dumbscan.html&#39;);">http://www.kyuzz.org/antirez/papers/dumbscan.html</a></p>
<p><a href="http://www.kyuzz.org/antirez/papers/moreipid.html" onclick="__gaTracker(&#39;send&#39;, &#39;event&#39;, &#39;outbound-article&#39;, &#39;http://www.kyuzz.org/antirez/papers/moreipid.html&#39;, &#39;http://www.kyuzz.org/antirez/papers/moreipid.html&#39;);">http://www.kyuzz.org/antirez/papers/moreipid.html</a></p>
<p><a href="http://en.wikipedia.org/wiki/Idle_scan" onclick="__gaTracker(&#39;send&#39;, &#39;event&#39;, &#39;outbound-article&#39;, &#39;http://en.wikipedia.org/wiki/Idle_scan&#39;, &#39;http://en.wikipedia.org/wiki/Idle_scan&#39;);">http://en.wikipedia.org/wiki/Idle_scan</a></p>
<div class="ig_inline_container ig_the_content ig_after"></div>
     
      <nav class="series-pagination">
        <ul>
                      <li class="prev">
              <a href="http://resources.infosecinstitute.com/nmap-cheat-sheet/#article" rel="prev">Prev: Nmap Cheat Sheet: From Discovery to Exploits – Part 1: Introduction to Nmap</a>
            </li>
                    
                      <li class="next">
              <a href="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-3-gathering-additional-information-host-network-2/#article" rel="next">Next: Nmap Cheat Sheet: From Discovery to Exploits, Part 3: Gathering Additional Information about Host and Network</a>
            </li>
                  </ul>
      </nav>
      
    </article>
    
    <section class="post-author large">
  
  <div class="image">
    <img alt="" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/a460e68b3e515acfbaba5af7f895b057" srcset="http://1.gravatar.com/avatar/a460e68b3e515acfbaba5af7f895b057?s=192&amp;d=mm&amp;r=g 2x" class="avatar avatar-96 photo" height="96" width="96">
  </div>
  
  <div class="name">
    <span>Author</span>
    <h5>
      <a href="http://resources.infosecinstitute.com/author/revers3r">Revers3r</a>
    </h5>
  </div>
  
  <div class="description">
    Revers3r is a Information Security Researcher with considerable experience in Web Application Security, Vulnerability Assessment, Penetration Testing. He is also well-versed in Reverse Engineering, Malware Analysis. He's been a contributor to international magazines like Hakin9, Pentest, and E-Forensics. In his free time, he's contributed to the Response Disclosure Program. website: www.vulnerableghost.com
  </div>
  
    
</section>    
    <ul class="random-posts ">
      <li style="background-image: url(&#39;http://2we26u4fam7n16rz3a44uhbe1bq2.wpengine.netdna-cdn.com/wp-content/uploads//031016_2337_DDoSAttacks2-237x237-c-default.jpg&#39;);">
      <a class="icon post-l" href="http://resources.infosecinstitute.com/ddos-attacks-targets-and-smoke-mirrors-mode/" title="DDoS Attacks: Targets and ‘Smoke &amp; Mirrors’ Mode">
        <h3>DDoS Attacks: Targets and ‘Smoke &amp;…</h3>
      </a>
    </li>
      <li style="background-image: url(&#39;http://2we26u4fam7n16rz3a44uhbe1bq2.wpengine.netdna-cdn.com/wp-content/uploads//Ransomware-237x237-c-default.jpg&#39;);">
      <a class="icon post-l" href="http://resources.infosecinstitute.com/top-7-android-ransomware-threats/" title="Top 7 Android Ransomware Threats">
        <h3>Top 7 Android Ransomware Threats</h3>
      </a>
    </li>
      <li style="background-image: url(&#39;http://2we26u4fam7n16rz3a44uhbe1bq2.wpengine.netdna-cdn.com/wp-content/uploads//SIEM-01212015-237x237-c-default.jpg&#39;);">
      <a class="icon post-l" href="http://resources.infosecinstitute.com/developments-in-machine-learning-vs-traditional-siem-solutions/" title="Developments in Machine Learning vs. Traditional SIEM Solutions">
        <h3>Developments in Machine Learning vs. Traditional…</h3>
      </a>
    </li>
      <li style="background-image: url(&#39;http://2we26u4fam7n16rz3a44uhbe1bq2.wpengine.netdna-cdn.com/wp-content/uploads//030916_2324_TestLabV8Pa2-237x237-c-default.png&#39;);">
      <a class="icon post-l" href="http://resources.infosecinstitute.com/test-lab-v8-part-i/" title="Test Lab V8 Part – I">
        <h3>Test Lab V8 Part – I</h3>
      </a>
    </li>
  </ul>    
    <div class="comments">
  
<div id="disqus_thread"><iframe id="dsq-app2" name="dsq-app2" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/saved_resource.html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 1305px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div>


</div>  
  </div>

        </div>
      </section>
      
              <footer class="site-footer">
  
  <div class="ctas full">
    
    <div class="col-3-3 wrapper">
      
      <div class="col-1-3">
        <h6>About InfoSec</h6>
        <p>InfoSec Institute is the best source for high quality <a href="http://www.infosecinstitute.com/" style="color:#fff;">information security training</a>. We have been training Information Security and IT Professionals since 1998 with a diverse lineup of relevant training courses. In the past 16 years, over 50,000 individuals have trusted InfoSec Institute for their professional development needs! </p>

      </div>
      
      <div class="col-1-3">
        <h6>Connect with us</h6>
        <p>Stay up to date with <a href="http://www.infosecinstitute.com/" style="color:#fff;">InfoSec Institute</a> and <a href="http://www.intenseschool.com/" style="color:#fff;">Intense School</a> - at info@infosecinstitute.com</p>

        <ul class="footer-social">
  <li>
    <div class="fb-like" data-href="http://resources.infosecinstitute.com" data-width="90" data-layout="button_count" data-action="like" data-show-faces="false" data-share="false"></div>
  </li>
  <li>
    <iframe id="twitter-widget-0" scrolling="no" frameborder="0" allowtransparency="true" class="twitter-follow-button twitter-follow-button-rendered" title="Twitter Follow Button" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/follow_button.c60d5b0c77548151ea09cd595348dc2d.en.html" style="position: static; visibility: visible; width: 129px; height: 20px;" data-screen-name="infosecedu"></iframe>
  </li>
</ul>      </div>
      
      <div class="col-1-3">
        <form action="http://resources.infosecinstitute.com/newsletter/signup" method="post" class="mailchimp has-loader" novalidate="">
  
  <aside>
    <h6>Join our newsletter</h6>
    <p>Get the latest news, updates &amp; offers straight to your inbox.</p>

  </aside>
  
  <fieldset>
    <input type="email" title="Email address" value="" name="EMAIL" placeholder="Enter your email">
    <input type="submit" value="Subscribe" class="generic-cta green">
    <input type="text" name="b_2593cfe26893087ed36e00fe3_ba06ce498c" tabindex="-1" value="">
  </fieldset>
  
</form>      </div>
      
    </div>
    
  </div>
  
  <div class="navigation full">
    
    <div class="col-3-3 wrapper">
      
      <nav class="footer">
        <ul>
                  </ul>
      </nav>

      <div class="copyright">© InfoSec Resources 2016</div>
      
    </div>
    
  </div>

</footer>            
    </main>
    
      <div class="modal" style="top: 49px;">
  <div class="modal-inner">
    <a rel="modal:close">Close</a>
    <div class="modal-content"></div>
  </div>
</div>

<div id="modal-hidden">
                <div id="download">
  <div class="pardot form">
    <h4 class="pardot-title">File download</h4>
    <form id="download-form" action="https://go.pardot.com/l/12882/2014-12-11/cqhcw" method="post"><input type="hidden" name="entry_title" value="Nmap Cheat Sheet: From Discovery to Exploits, Part 2: Advance Port Scanning with Nmap And Custom Idle Scan">
      <input type="hidden" name="download_title" value="">
      <input type="hidden" name="resources_training" value="">

      
      <input type="hidden" name="url" value="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/">
      <input type="hidden" name="entry_id" value="26390">
      <input type="hidden" name="entry_url" value="http://resources.infosecinstitute.com/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan/">
      <input type="hidden" name="entry_type" value="">

      <ul>
        <li data-required="">
          <label>First Name</label>
          <input name="first_name">
        </li>
        <li data-required="">
          <label>Last Name</label>
          <input name="last_name">
        </li>
        <li data-required="">
          <label>Work Phone Number</label>
          <input name="phone">
        </li>
        <li data-required="">
          <label>Work Email Address</label>
          <input name="email">
        </li>
        <li>
          <label>Job Title</label>
          <input name="job_title">
        </li>
                  <li class="training-fund">
            <label>How will you fund your training?</label>
            <div class="dd" data-selected="No current plan">
              <select name="training_fund">
                                  <option value="No current plan
">No current plan
</option>
                                  <option value="Employer Paid
">Employer Paid
</option>
                                  <option value="GI Bill
">GI Bill
</option>
                                  <option value="Tuition Assistance
">Tuition Assistance
</option>
                                  <option value="Self Pay
">Self Pay
</option>
                                  <option value="Other">Other</option>
                              </select>
            </div>
          </li>
                          <li class="training-why">
            <label>Why Take This Training?</label>
            <div class="dd" data-selected="I&#39;m not interested in training">
              <select name="training_why">
                                  <option value="I&#39;m not interested in training
" title="I&#39;m not interested in training
">I'm not interested in training
</option>
                                  <option value="To get certified - company mandated
" title="To get certified - company mandated
">To get certified - company mandated
</option>
                                  <option value="To get certified - my own reasons
" title="To get certified - my own reasons
">To get certified - my own reasons
</option>
                                  <option value="To improve my skillset - get a promotion
" title="To improve my skillset - get a promotion
">To improve my skillset - get a promotion
</option>
                                  <option value="To improve my skillset- for a new job
" title="To improve my skillset- for a new job
">To improve my skillset- for a new job
</option>
                                  <option value="Other" title="Other">Other</option>
                              </select>
            </div>
          </li>
                          <li class="training-timeline">
            <label>What is your timeline for training?</label>
            <div class="dd" data-selected="I have no current timeline for training">
              <select name="training_timeline">
                                  <option value="I have no current timeline for training
">I have no current timeline for training
</option>
                                  <option value="Within a month
">Within a month
</option>
                                  <option value="1-3 months
">1-3 months
</option>
                                  <option value="3-6 months
">3-6 months
</option>
                                  <option value="6-12 months
">6-12 months
</option>
                                  <option value="Over 1 year">Over 1 year</option>
                              </select>
            </div>
          </li>
                <li class="full">
          <input type="submit" class="generic-cta green" value="Download files">
        </li>
      </ul>

      <p>InfoSec institute respects your privacy and will never use your personal information for anything other than to notify you of your requested course pricing. We will never sell your information to third parties. You will not be spammed.</p>

      <div style="position:absolute; left:-9999px; top: -9999px;">
        <label for="pardot_extra_field">Comments</label>
        <input type="text" id="pardot_extra_field" name="pardot_extra_field">
      </div>

    </form>
  </div>
</div>            <div id="skillset-modal">
  <div class="skillset window">
    <h4>What is Skillset?</h4>
    <aside>
      
      <div class="left">
        <h3>Skillset</h3>
        <h5>Practice tests &amp; assessments.</h5>
      </div>
      
      <div class="right">
        <p>Practice for certification success with the Skillset library of over 100,000 practice test questions. We analyze your responses and can determine when you are ready to sit for the test. Along your journey to exam readiness, we will:</p>
<p></p>
<p>1. Determine which required skills your knowledge is sufficient<br>
2. Which required skills you need to work on<br>
3. Recommend specific skills to practice on next<br>
4. Track your progress towards a certification exam</p>

      </div>
      
    </aside>
  </div>
</div>    </div>      
    <script src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/in.js" type="text/javascript">lang: en_US</script>

<script>
window.twttr=(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return;js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);t._e=[];t.ready=function(f){t._e.push(f);};return t;}(document,"script","twitter-wjs"));
</script>

<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.3&appId=552038044933986";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<script src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/platform.js" async="" defer="" gapi_processed="true"></script>      
      <script>var postID = 26390;</script>
    
    <script type="text/javascript">
    			jQuery(function() {
    				jQuery( window ).on( 'init.icegram', function( e, ig ) {
				        jQuery('.ig_inline_container:empty').remove();
				    });
    			});
    		 </script>
<style type="text/css">
.ig_hide .wpcf7-response-output,
.ig_form_container .screen-reader-response{
	display: none !important;
}
.ig_show .ig_form_container.layout_bottom .wpcf7-response-output,
.ig_show .ig_form_container.layout_right .wpcf7-response-output,
.ig_show .ig_form_container.layout_left .wpcf7-response-output{
	background-color: #FFF;
	color: #444;
	position: absolute;
}
.ig_sidebar .ig_form_bottom.ig_show .ig_form_container.layout_bottom .wpcf7-response-output{
	bottom: 0;
}
.ig_overlay.ig_form_bottom.ig_show .ig_form_container.layout_bottom .wpcf7-response-output,
.ig_action_bar.ig_bottom.ig_show .ig_form_container.layout_right .wpcf7-response-output,
.ig_action_bar.ig_bottom.ig_show .ig_form_container.layout_left .wpcf7-response-output{
	bottom: 100%;
}
</style>

<script type="text/javascript">
jQuery(function() {
  	jQuery( window ).on( "init.icegram", function(e, ig) {
	  	// Find and init all CF7 forms within Icegram messages/divs and init them
	  	if(ig){
		  	jQuery.each(ig.messages, function(i, msg){

		  		jQuery(msg.el).find('form input[name=_wpcf7]').each(function(){
			  		var form = jQuery(this).closest('form');
			  		if(form && !form.hasClass('ig_form_init_done')){
			  			if(form.closest('.ig_form_container').length > 0){
				  			if(form.parent().find('.screen-reader-response').length == 0){
				  				form.before('<div class="screen-reader-response"></div>')
				  			}
				  			if(form.find('wpcf7-response-output').length == 0){
				  				form.append('<div class="wpcf7-response-output wpcf7-display-none"></div>')
				  			}
					  		form.closest('.ig_form_container').attr('id', form.find('input[name=_wpcf7_unit_tag]').val()); //_wpcf7_unit_tag
			  			}
			  			form.wpcf7InitForm();
			  			form.addClass('ig_form_init_done');
			  		}
		  		});

		  	});
	  	}

  	}); // init.icegram
	
	// Dismiss response text/div when shown within icegram form container
	jQuery('body').on('click', '.ig_form_container .wpcf7-response-output', function(e) {
			jQuery(e.target).slideUp();
	});
	// Handle CTA function(s) after successful submission of form
  	jQuery( window ).on('wpcf7:mailsent', function(e) {
  		if( typeof icegram !== 'undefined'){
		  	var msg_id = (jQuery(e.target.closest('[id^=icegram_message_]')).attr('id') || '').split('_').pop() || 0 ;
		  	var ig_msg = icegram.get_message_by_id(msg_id) || undefined;
		  	if(ig_msg && ig_msg.data.cta === 'form_via_ajax' && ig_msg.data.cta_option_form_via_ajax == 'hide_on_success'){
				ig_msg.hide();
		  	}
  		}
	});

});
</script>

			<script type="text/javascript">
<!--
piCId = '1951';
piAId = '13882';


(function() {
	function async_load(){
		var s = document.createElement('script'); s.type = 'text/javascript';
		s.src = ('https:' == document.location.protocol ? 'https://pi' : 'http://cdn') + '.pardot.com/pd.js';
		var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
	}
	if(window.attachEvent) { window.attachEvent('onload', async_load); }
	else { window.addEventListener('load', async_load, false); }
})();
-->
</script><script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/form.js"></script>
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/shCore.js"></script>
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/shBrushCpp.js"></script><iframe name="oauth2relay385983450" id="oauth2relay385983450" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/postmessageRelay.html" tabindex="-1" style="width: 1px; height: 1px; position: absolute; top: -51px;"></iframe>
<script type="text/javascript">
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var themecssurl = "http://resources.infosecinstitute.com/wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9b";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['pad-line-numbers'] = false;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/app.js"></script>
<script type="text/javascript">
/* <![CDATA[ */
var embedVars = {"disqusConfig":{"platform":"wordpress@4.3.3","language":"","remote_auth_s3":"W10= 48f2b8da0b11f3bc59174d2d1612bc4746dc3bee 1457931175","api_key":"1TA9XhBKpqfZxr6kJiBvCescmAiajXtudB0o4aJYPZguLsFA5bUOtWPGbsoOAiku","sso":{"name":"InfoSec Resources","button":false,"url":"http:\/\/resources.infosecinstitute.com\/wp-login.php","logout":"http:\/\/resources.infosecinstitute.com\/wp-login.php?action=logout","width":"800","height":"700"}},"disqusIdentifier":"26390 http:\/\/resources.infosecinstitute.com\/?p=26390","disqusShortname":"infosecinstituteresources","disqusTitle":"Nmap Cheat Sheet: From Discovery to Exploits, Part 2: Advance Port Scanning with Nmap And Custom Idle Scan","disqusUrl":"http:\/\/resources.infosecinstitute.com\/nmap-cheat-sheet-discovery-exploits-part-2-advance-port-scanning-nmap-custom-idle-scan\/","options":{"manualSync":false},"postId":"26390"};
/* ]]> */
</script>
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/disqus.js"></script>
<script type="text/javascript">
/* <![CDATA[ */
var countVars = {"disqusShortname":"infosecinstituteresources"};
/* ]]> */
</script>
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/count(1).js"></script>
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/jquery.js"></script>
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/jquery-migrate.min.js"></script>
<script type="text/javascript">
/* <![CDATA[ */
var icegram_pre_data = {"ajax_url":"http:\/\/resources.infosecinstitute.com\/wp-admin\/admin-ajax.php","post_obj":{"is_home":false,"page_id":26390,"action":"display_messages","shortcodes":[],"cache_compatibility":"yes","device":"laptop"}};
/* ]]> */
</script>
<script type="text/javascript" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/main.js"></script>

    
  
  
<script type="text/javascript" id="ig_script_0" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/icegram.js"></script><script type="text/javascript" id="ig_script_1" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/main(1).js"></script><script type="text/javascript" id="ig_script_2" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/frontend.js"></script><script type="text/javascript" id="ig_script_3" src="./Nmap Cheat Sheet_ From Discovery to Exploits, Part 2_ Advance Port Scanning with Nmap And Custom Idle Scan - InfoSec Resources_files/frontend(2).js"></script><div id="icegram_messages_container"><div class="icegram action_bar_32821"><div class="ig_action_bar ig_container ig_hello ig_no_hide ig_top ig_no_icon ig_show ig_anim_slide_in" id="icegram_message_32821" style="display: block;"><div class="ig_content ig_clear_fix"><div class="ig_close" id="ig_close_32821"><span></span></div><div class="ig_data ig_clear_fix"><div class="ig_headline">Pass the CISSP exam. Faster. Guaranteed.</div><div class="ig_message" style="display: none;"></div></div><div class="ig_button" style="cursor: pointer;">Visit Skillset CISSP</div></div></div></div></div><iframe id="rufous-sandbox" scrolling="no" frameborder="0" allowtransparency="true" allowfullscreen="true" style="position: absolute; visibility: hidden; display: none; width: 0px; height: 0px; padding: 0px; border: none;"></iframe></body></html>